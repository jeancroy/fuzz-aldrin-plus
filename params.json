{"name":"Fuzzaldrin-plus","tagline":"Sublime text like fuzzy filtering - compatible with fuzzaldrin","body":"## What is fuzzaldrin-plus?\r\n\r\n- A fuzzy search / highlight that specialize for programmer text editor. It tries to provide intuitive result by recognizing patterns that people use while searching.\r\n\r\n- A rewrite of the fuzzaldrin library. API is backward compatible with some extra options. Tuning has been done from report usage of the Atom text editor.\r\n\r\n- At this point in time, it may either be merged back into fuzzaldrin or lives as a forked library, we'll see.\r\n\r\n\r\n## What Problem are we trying to solve?\r\n\r\n### Score how matched characters relate to one another.\r\n\r\n- One of the most often reported issues is not being able to find an exact match.\r\n- A great source of questionable results come from scattered character, spread seemingly randomly in the string.\r\n\r\nWe plan to address those issues by scoring runs of consecutive characters. In that scheme, an exact match will be a special case where the run is 100% of the query length.\r\n\r\nIn original fuzzaldrin, candidate length was used as a proxy for match quality. This work reasonably well when subject is a single word, but break when subject contain multiple words, for example, see:\r\n\r\n- **Core**\r\n- **Co**nt**r**oll**e**r\r\n- Extention**Core**\r\n\r\nIn `Core` vs. `Controller` size is a good indicator of quality, but not so much in `Controller` vs. `ExtentionCore`. This situation happens because match compactness matters more than haystack size. Match compactness is the principle behind the scoring of the *Selecta* project.\r\n\r\n\r\n#### Run length / consecutive\r\n\r\nSo far the examples can be handled by an `indexOf` call. However, there are times where a single query can target multiple parts of a candidate.\r\n\r\nFor example when candidate contains multiple words\r\n- `git push` vs. `Git Plus: Push`\r\n- `email handler` vs. `email/handler.py`\r\n\r\nAnother example is to jump over common strings.\r\n- `toLowerCase`\r\n- `toLocaleString`\r\n- `toLocalLowerCase`\r\n\r\nWe could use a query like `tololo`  to select the third option of these.\r\n\r\n\r\n### Select character based on score.\r\n\r\nThe previous algorithm always selects the first available matching character (leftmost alignment). Only after selection, it will try to identify how to score that character. The problem then is that the most interesting instance of a character is not necessarily on the left.\r\n\r\nFor example on query `itc`, we should match\r\n-  **I**mportance**T**able**C**trl.\r\n\r\nInstead leftmost aligement miss the acronym pattern:\r\n- **I**mpor**t**an**c**eTableCtrl.\r\n\r\nFor query `core` against `controller_core` leftmost alignment miss the consecutive run:\r\n- **co**nt**r**oll**e**r_core\r\n\r\nTo handle this, we propose to embed the pattern detection (consecutive and more) inside an optimal alignment scheme. Imagine you have an algorithm that allows you to recognize objects in images; it would make little sense to run it exclusively on the top left corner.\r\n\r\n\r\n### Prevent Accidental acronym.\r\n\r\nFuzzladrin handles acronym by giving a large bonus on character matches that start words.  Currently, a start-of-word bonus matches almost as much as three proper-case character.\r\n\r\nFor query `install` should result be in this order ?\r\n- F**in**d & Replace **S**elec**t** **All**\r\n- Application: **Install**\r\n\r\nIn that example, we have '**S**elect **A**ll' boost the score of the first candidate because we score two word-starts while we only score one for 'install'.\r\n\r\nFor query `git push`, should we order result in that order ?\r\n- \"**Git** **P**l**u**s: **S**tage **H**unk\"\r\n- \"**Git** Plus: **Push**\"\r\n\r\nWhat about the fact we match three start-of-words in `Plus Stage Hunk`? PSH is very close to '**p**u**sh**' (And `Plus` contains `u`).\r\n\r\nThat kind of question arises even more often when we use optimal selection because the algorithm will lock on those extra acronym points.\r\n\r\nWhat we propose in this project is that start-of-words characters should only have a moderate advantage by themselves. Instead, they form strong score by making an acronym pattern with other start-of-words characters.\r\n\r\nFor example with query `push`:\r\n- against `Plus: Stage Hunk`:  we have `P + u + SH`  grouped as 1, 1, 2\r\n- against `push`:  we have a  single group of 4.\r\n- The substring wins for having the largest group\r\n\r\nFor example with query `psh`:\r\n- against `Plus: Stage Hunk`: we have `PSH` so a single group of 3\r\n- against `push`: we have `p + sh` so grouped as 1, 2\r\n- The acronym wins for having the largest group.\r\n\r\n\r\nThis way we can score both substring and acronym match using the structure of the match. We'll refine the definition of consecutive acronym later.\r\n\r\n\r\n### Score the context of the match.\r\n\r\nSome people proposed to give a perfect score to exact case-sensitive matches. This proposition can be understood because exact matches and  case-sensitivity are two area where fuzzaldrin is not great.\r\n\r\nHowever should 'sw**itc**h.css' be an exact match for `itc`?\r\nEven when we have **I**mportance**T**able**C**trl available?\r\n\r\nFew people will argue against `diag` preferring `diagnostic` to `Diagnostics`.\r\n\r\nHowever should `install` prefer \"Un**install**\" over \"**Install**\" ? Or should it be the other way around?  In this case, we have to consider the relative priority of case-sensitivity and start-of-word.\r\n\r\nExact matches are used with enougth frequency that we should not only ensure they win against approximate matches but also ensure to rank quality properly amongst them.\r\n\r\n### Manage the multiples balances of path scoring.\r\n\r\nWe want to prefer match toward the start of the string.\r\nExcept we also want to prefer match in the filename (which happens near the end of the string)\r\n\r\nWe want to prefer shorter and shallower path.\r\nExcept we also want to retrieve some deeper files when filename is clearly better.\r\n\r\nWe want to prefer matches in the filename\r\nExcept when the query describes a full path much better than an approximate file name. (Let's consider query `model user` vs `models/user.rb` or `moderator_column_users.rb`)\r\n\r\n\r\n## Proposed Scoring Rules\r\n\r\n\r\n### 1. Characters are chosen by their ability to form a pattern with others.\r\n\r\nPatterns can be composed of\r\n - consecutive letters of the subject,\r\n - sequential letters in the Acronym of the subject.\r\n\r\nStart-of-words (acronym) characters are special in that they can either forms pattern with the rest of the word or with other acronym characters.\r\n\r\n- Pattern based scoring replaces a situation where acronyms characters have a large bonus by themselves. Now the bonus is still large but conditional to being part of some pattern.\r\n\r\n- CamelCase and snake_case acronym are treated exactly the same. They will, however, get different score for matching uppercase/lowercase query\r\n\r\n\r\n### 2. Primary score attribute is pattern length.\r\n\r\n- A pattern that span 100% of the query length is called an exact match.\r\n     - There is such a thing as an acronym exact match.\r\n\r\n- Because every candidate is expected to match all of query larger group should win against multiple smaller one.\r\n    - The rank of a candidate is the length of it's largest pattern.\r\n    - When all patterns of a first candidate are larger than patterns in a second one, the candidate with the highest rank is said to be dominant.\r\n        - 1 group of 6 >  2 group of 3 > 3 group of 2.\r\n\r\n    - When some groups are larger, and some are smaller, the highest rank match is said to be semi-dominant.\r\n         - Let's consider a first candidate grouped as 4+2 vs. a second candidate grouped as 3+3.\r\n              - The first group of 4 wins against the first group of 3.\r\n              - However, the group of 2 loose against the second group of 3.\r\n             - In this case, we'll consider some extra information.\r\n\r\n### 3. Secondary score attribute is the quality of matches.\r\n\r\n- Match quality is made of proper casing and context score\r\n    - The main role of match quality is to order candidate of the same rank.\r\n    - When match is semi-dominant match quality can overcome a small rank difference.\r\n\r\n- Context score considers where does the match occurs in the subject.\r\n    - Full-word > Start-of-word > End-of-word > Middle-of-word\r\n    - On that list, Acronym pattern score at Start-of-word level. (That is just bellow full-word)\r\n\r\n- Score for a proper case query has both gradual and absolute components.\r\n   - The less error, the better\r\n   - 100% Case Error will be called wrong-case, for example matching a `CamelCase` acronym using lowercase query `cc`.  \r\n   - Exactly 0 error is called CaseSentitive or ExactCase match.\r\n     - CaseSentitive matches have a special bonus that is smaller than start-of-word bonus but greater than the end-of-word bonus.\r\n     - This scoring scheme allows a start-of-word case-sensitive match to overcome a full-word wrong-case match.\r\n     - It also allows to select between a lowercase consecutive and CamelCase acronym using case of query.\r\n     - To answer the question asked in the introduction, \"Installed\" win over \"Uninstall\" because start-of-word > Exact Case.\r\n\r\n- **Q:** Why can't you simply add extra length for some bonus. For example, score a start-of-word match as if it had an extra character.\r\n   - **A:** We cannot do that on partial matches because then the optimal alignment algorithm will be happy to split word and collect start-of-word bonus like stamps. (See accidental acronym)\r\n\r\n- **Q:** Why do you add extra length on exact matches?\r\n   - **A:** First, once you have matched everything, there's no danger of splitting the query. Then,  that bonus exists to ensure exact matches will bubble up in the firsts results, despite longer/deeper path. If, after more test and tuning, we realize it's not needed, we'll be happy to remove it, the fewer corner cases, the merrier.\r\n\r\n- **Q:** Why are you using lowercase to detect CamelCase?\r\n  - **A** CamelCase are detected as a switch from lowercase to UPPERCASE. Defining UPPERCASE as not-lowercase, allow case-invariants characters to count as lowercase.   For example `Git Push` the `P` of push will be recognised as CamelCase because we consider `<space>` as lowercase. \r\n\r\n### 4. Tertiary score attributes are subject size, match position and directory depth\r\n\r\n- Mostly there to help order match of the same rank and match quality, unless the difference in tertiary attributes is large.\r\n     -(Proper definition of large is to be determined using real life example)\r\n\r\n- In term of the relative importance of effects it should rank start-of-string > string size > directory depth.\r\n\r\n## Score Range\r\n\r\n- **Score is 0 if and only if there is no match.**\r\n\r\n- Otherwise, the score is a strictly positive integer.\r\n\r\n- The maximum range is `score(query,query)` whatever that number is. A longer query will have a greater maximal score.\r\n\r\n- Score exist mainly to for relative order with other scores of the same query and to implements scoring rule described above. \r\n\r\n- Score have a high dynamic range and consider a lot of information. Equality is unlikely. For that reason, **multiplicative bonuses should be preferred over additive ones**.\r\n\r\n-------------\r\n\r\n### Acronym Prefix\r\nMore detail on acronym match\r\n\r\n\r\nAn acronym prefix is a group of characters that are consecutive in the query and sequential in the acronym of the subject. That group starts at the first character of the query and end at the first character of the query, not in the acronym. If there's no missed character, then we have an acronym exact match (100% of query is sequential in the acronym)\r\n\r\n\r\n**For example if we match `ssrb` against `Set Syntax Ruby` we'll score it like so**\r\n\r\n````\r\n  012345678901234\r\n \"Set Syntax Ruby\"\r\n \"000 SSR0b0 0000\"\r\n````\r\n\r\n- Acronym scored as three consecutive character at start-of-word + an isolated letter.\r\n- Here we have a wrong-case match. \"SSRb\" or \"SSRB\" would have case-sensitive points on the acronym pattern (case of isolated letter is not important)\r\n- Position of the equivalent consecutive match is the average position of acronym characters.\r\n- For scoring, we use the size of the original candidate.\r\n\r\n\r\n**Another example is matching `gaa` against `Git Plus: Add All` we'll score it like so**\r\n\r\n````\r\n  01234567890123456\r\n \"Git Plus: Add All\"\r\n \"000000 GAA00 0000\"\r\n````\r\n\r\n- here we conveniently allow to skip the `P` of `Plus`.\r\n\r\n\r\n**Then what about something like \"git aa\" ?**\r\n\r\nThis is a current limitation. We do not support acronym pattern outside of the prefix. Mostly for performance reason.\r\nAcronym outside of the acronym prefix will have some bonus, scoring between isolated character and 2 consecutive.\r\nThere are multiple thing we can improve if one day we implement a proper multiple word query support, and this is one of them.\r\n\r\n### Optional characters\r\n\r\nLegacy fuzzaldrin had some support for optional characters (Mostly space, see `SpaceRegEx`). Because the scoring does not support errors, the optional character was simply removed from the query.\r\n\r\nWith this PR, optimal alignment algorithm supports an unlimited number of errors. The strict matching requirement is handled by a separate method `isMatch`. The optional character implementation is done by building a subset of the query containing only non-optional characters (`coreQuery`) and passing that to `isMatch`.\r\n\r\nThis new way of doing thing means that while some characters are optional, candidates that match those characters have a better score. What this allow is to add characters to the optional list without compromising ranking.\r\n\r\nOptional character contains space, but also `-` and `_` because multiple specs require that we should treat them as space. Also `\\` and `:` are also optional to support searching a file using the PHP or Ruby name-space. Finally `/` is optional to mirror `\\` and support a better workflow in a multi-OS environment.\r\n\r\nFinally option `allowErrors` would make any character optional. Expected effect of that options would be some forgiveness on the spelling at the price of a slower match.\r\n\r\n\r\n### Path Scoring\r\n\r\n- Score for a given path is computed from the score of the fullpath and score of the filename. For low directory depth, the influence of both is about equal. But, for deeper directory, there is less retrieval effect (importance of basename) \r\n\r\n- The full path is penalized twice for size. Once for its own size, then a second time for the size of the basename. Extra basename penalty is dampened a bit.\r\n\r\n- The basename is scored as if `allowErrors` was set to true. (Full-path must still pass `isMatch` test).  This choice is made to support query such as `model user` against path `model/user`. Previously, the basename score would be 0 because it would not find `model` inside basename `user`. Variable `queryHasSlashes` partially addressed this issue, but was inconsistent with usage of `<space>` as folder separator\r\n\r\n- When query has slashes (`path.sep`) the last or last few folder from the path are promoted to the basename. (as many folder from the path as folder in the query)\r\n\r\n-------------\r\n\r\n## Algorithm (Optimal alignment)\r\n\r\n### LCS: Dynamic programming Table\r\nLet's compare  A:`surgery` and B:`gsurvey`.\r\nTo do so we can try to match every letter of A against every letter of B.\r\n\r\nThis problem can be solved using a score matrix.\r\n- The match starts at [0,0] trying to compare the first letter of each.\r\n- The match end at [m,n] comparing the last letter of each.\r\n\r\nAt each position [i,j] the best move can be one of the 3 options.\r\n\r\n- match `A[i]` with `B[j]` (move diagonal, add 1 to score)\r\n- skip `A[i]` (move left, copy score)\r\n- skip `B[j]` (move down, copy score)\r\n\r\nWe do not know which one of these 3 is the best move until we reach the end, so we record the score of the best move so far. The last cell contains the score of the best alignment. If we want to output that alignment we need to rebuild it backward from the last cell.\r\n\r\n````\r\n    s u r g e r y\r\n g [0,0,0,1,1,1,1]  : best move is to align `g` of *g*survey with `g` of  sur*g*ery, score 1\r\n s [1,1,1,1,1,1,1]  : we can align `s`, but doing so invalidate `g`. Both score 1, we cannot decide\r\n u [1,2,2,2,2,2,2]  : if we align s, we can also align u, we have a winner\r\n r [1,2,3,3,3,3,3]  : we can align `r`\r\n v [1,2,3,3,3,3,3]  : nothing we can do with that `v`, score stay the same\r\n e [1,2,3,3,4,4,4]  : we can align `e`  (we skipped `g` the same way we skipped `v`)\r\n y [1,2,3,3,4,4,5]  : align y (we skipped `r` )\r\n````\r\n\r\n**Best alignment is**\r\n\r\n````\r\ngsur-ve-y\r\n-|||--|-|\r\n-surg-ery\r\n````\r\n\r\nFor those familiar with code diff, this is essentially the same problem. Except, in this case, we the do the alignment of characters in a word and a diff performs alignment of lines in a file. Characters present in the second word but not in the first counts as additions; characters present only in the first word are deletions and characters present in both are matches - like unchanged lines in a diff.\r\n\r\nTo get that alignment, we start from the last character and trace back the best option.  The pattern to looks for an **alignment** is the corner increase (diagonal+1 is greater than left or up.)\r\n\r\n````\r\n4,4   3,3   2,2    1,1    0,0\r\n4,5   3,4   2,3    1,2    0,1\r\n````\r\n\r\n- (There are an implicit row and column of 0 before the matrix)\r\n\r\nThe pattern to look for to **move left** is:\r\n\r\n````\r\n3,3\r\n4,4\r\n````\r\n\r\nThe pattern to look for to **move up** is:\r\n\r\n````\r\n3,4\r\n3,4\r\n````\r\n\r\nWe try to resolve equality the following way:\r\n\r\n````\r\n3,3\r\n3,3\r\n````\r\n\r\n1. Prefer moving UP: toward the start of the candidate. This strategy ensures we highlight toward the start of string instead of the end when all else is equal.\r\n2. If not available, prefer moving LEFT (optional character)\r\n3. Only accept alignment DIAG when it is the absolute best option.\r\n\r\n\r\n\r\n\r\n### Algorithm Conclusion\r\n\r\nThe LCS algorithm allows to detect which character of the query are common to both words while being in proper order. (For example g is common to both word but discarded because out of order.)\r\n\r\nLCS is not immediately useful for fuzzaldrin needs. Because fuzzaldrin require ALL characters of the query to be in subject to have a score greater than 0, LCS for all positive candidates would be the length of the query.\r\n\r\nHowever, the dynamic programming table used to solve LCS is very useful to our need. The ability to select the best path and skip that `g` even if it is present in both query and candidate is the key to improves over left-most alignment. All we need for this to works is a bit more detail in score than 0 or 1. \r\n\r\n### Similarity score\r\n\r\nMatching character does not have to be binary. Case sensitive match can still prefer proper case, same goes with accents. A diff tools can decide a line has been modified, instead of registering an addition and a deletion. A handwriting recognition tool can decide `a` and `o` are somewhat more similar to each other than they are to `w`, and so on.\r\n\r\nWe use character similarity as a way to build and score patterns. That is, we consider that character are similar from their own quality ( such as case) as well of being part of a similar neighborhood (consecutive letters or acronyms)\r\n\r\nThere are some rules that limit our scoring ability (for example we cannot go back in time and correct the score based on future choice) but overall that scheme is very flexible.\r\n\r\n### Where is the matrix?\r\n\r\nWhile the programming table describes computation, we do not need to store the whole matrix when we only output the score. Fundamentally when computing a score, we only need 3other previously computed cell: UP, LEFT and DIAG.\r\n\r\nSuppose we process the cell [3,5]\r\n\r\n20, 21, 22, 23, 24, 25, 26, *27, 28, 29*   \r\n*30, 31, 32, 33, 34,* **35**, 36, 37, 38, 39  \r\n\r\nTo build that score we only need values 24(DIAG), 25(UP), 34(LEFT).\r\nSo instead of a whole matrix we can keep only the two current lines.\r\n\r\nFurthermore, anything on the left of 24 on the first line is not needed anymore. Also, anything to the right of 35 on the second line has not yet been computed. So we can build a more compact structure using one composite row + one diagonal.\r\n\r\nscore_diag =  24    \r\nscore_row = 30, 31, 32, 33, 34, 25, 26, 27, 28, 29   \r\n\r\n#### Preparing next value\r\n\r\nOnce we have computed the value of the cell [3,5], we can insert that value into the structure, taking care of saving next diagonal before overwriting it.\r\n\r\ndiag =  25    \r\nrow = 30, 31, 32, 33, 34, **35**, 26, 27, 28, 29   \r\n\r\nTo compute value of cell [3,6] we take \r\n- UP value (26) from the row.\r\n- DIAG value, from the diag register. \r\n- LEFT value from the previously computed value: 35\r\n\r\n### Initial values\r\n\r\nBefore entering the matching process, the row is initialized with 0. Before scoring each row, the LEFT and DIAG register are reset to 0.\r\n\r\nThat strategy has the effect of placing a virtual row and column of 0 before the matrix. Moreover, it allows to deal with boundary condition without any special case.\r\n\r\n### Memory management\r\n\r\nWe set up the row vector with the size of the query. Using a full matrix, scoring a query of size 5 against a path of size 100, would require a 500 cells. Instead, we use a 5 item row + some registers. This should ease memory management pressure.\r\n\r\nEach character of the query manages its best score. More precisely, each cell `row[j]` manage the best score so far of matching `query[0..j]` against candidate[0..i]. \r\n\r\n### Consecutive Score (Neighbourhood) Matrix.\r\n\r\nWe cache the consecutive score in a virtual matrix following the same composite row scheme that we do with score values.\r\n\r\nIn `fuzzaldrin.score` The candidate entirely determines the Neighbourhood quality. It is not affected by which character has been chosen. In highlight, (`fuzzaldrin.match`) we further refine the formula to make the consecutive bonus conditional to not breaking the consecutive chain:\r\n\r\nFor example query `abcdz` vs. subject `abcdzbcdz`. Between `abcd` and `bcdz`, `abcd` wins for being sooner in the string. Now between the two `z`, the first one is isolated and the second one is part of a rank 4 group. However given that `bcd` are matched sooner, the second `z` is an isolated match, so the first `z` wins.\r\n\r\n-------------\r\n\r\n## Performance\r\n\r\nLet's consider the following autocomplete scenario.\r\n- Symbol bank has 1000 items.\r\n- The user receives about 5 suggestion for its query.\r\n- Of those 5, 1 is a exact case-sensitive match.\r\n- That particular user almost always wants that case sensitive match.\r\n\r\nShould we optimize for case sensitive `indexOf` before trying other things? Our answer to that question is no. \r\n\r\nCase sensitive exact match are valuable because they are rare. Even if the user tries to get them, for each one of those we have to reject 995 entry and deal with 4 other kinds of matches.\r\n\r\nThis is our first principle for optimization: **Most of the haystack is not the needle**. Because rejection of candidate happens often, we should be very good at doing that. \r\n\r\nFailing a test for case-sensitive `indexOf` tell us exactly nothing for case-insensitive `indexOf`, or acronyms, or even scattered letters.\r\nThat test is too specific. To reject match efficiently, we should aim for the lowest common denominator: scattered case-insensitive match.\r\n\r\nThis is exactly the purpose of `isMatch`.\r\n\r\n### Most of the haystack is not the needle\r\n\r\nWe just have shown how that sentence applies at the candidate level, but it is also at the character level. \r\n\r\n**Let's consider this line: `if (subject_lw[i] == query_lw[j])`**\r\nThis test is for match points (or hits). It refers to the `diag+1` in the algorithm description, with the `+1` being refined to handle the differents levels of character and neighborhood similarity.\r\n\r\n\r\n**How often is that condition true ?**\r\n\r\nLet's consider an alphabet that contain 26 lowercase letters, 10 numbers, a few symbols ` _!?=<>`. That is a 40+ symbol alphabet. Under a uniform usage model of those symbols, we have the hit condition occurs about 2.5% of the time (1/40). If we suppose only 10-20 of those characters are popular, the hit rate is about 5-10%.\r\n\r\nThis means we'll try to minimize the number of operation that happens outside of math points. In that context, increasing the cost of a hit, while decreasing the cost of non-hits looks like a possibly worthwhile proposition. \r\n\r\nA canonical example of this is that, instead of testing each character against the list of separators, setting a flag for next character being a start-of-word, we first confirm a match then look behind for separator. This characterization work is sometimes repeated more than once, but so far this scheme benchmarked better than alternatives we have tried to avoid doing extra work.\r\n\r\nHaving work concentrated at hit points is also a natural fit to our logic, the most expensive part being to determine how to score similarity between characters (including context similarity). However, it also means we'll want to have some control over the number of positive hits we'll compute - that is the purpose of missed hit optimisation.\r\n\r\n\r\n### What about a stack of needles?\r\n\r\nTo the extent the user is searching for a specific resource, this should be uncommon.\r\n\r\nIt can still happen in some situation such as:\r\n - Search is carried as user type (the query is not intentional)\r\n - The intentional query is not fully typed, match-all is a temporary step.\r\n\r\nOne way to deal with that is not to use the full matching algorithm when we can deal with something simpler. This is what we have done while searching for `indexOf` instance. \r\n\r\nOne special note: Acronym still have to be checked even if we have an exact match: for example query `su` against `StatusUrl`. As an exact match it is poor: 'Statu**sU**rl' is a middle of word match and have the wrong case. However as an acronym it is great: '**S**tatus**U**rl'. That motivated us to create the specialized `scoreAcronyms`.\r\n\r\nWhat is nice is that while `scoreAcronyms` was created to speed up exact matches search, it also provided very valuable information for accuracy. It later became a corner stone in the processing of accidental acronym. \r\n\r\nThe result is that for exact matches and exact acronym matches we bypass the optimal alignment algorithm, giving very fast results.\r\nWe still have to deal with fuzzier stacks of needles and the next two optimization address this.\r\n\r\n### Hit Miss Optimization.\r\n\r\nA hit occurs when character of query is also in the subject.\r\n - Every (i,j) such that subject[i] == query[j], in lowercase.\r\n\r\nA missed hit occurs when a hit does not improve the score.\r\n\r\nTo guarantee optimal alignment, every hit has to be considered.\r\nHowever when candidate are long (deep path) & query contains common use character, for example, vowels , we can spend a huge amount of time scoring accidental hits.\r\n\r\nSo we use the number of missed hit as a heuristic for current score that are unlikely to improve. Let's score `itc` vs `ImportanceTableControl`\r\n\r\n- `I` of `Importance`: First occurrence, improve over none.\r\n- `t` of `Importance`: First occurrence, improve over none.\r\n- `c` of `Importance`: First occurrence, improve over none.\r\n- `T` of `Table` : Acronym match, improve over an isolated middle of word.\r\n- `C` of `Control` : Acronym match, improve over an isolated middle of word.\r\n- `t` of `Control`: no improvement over acronym `T`: first hit miss.\r\n\r\n- After a certain threshold of missed hit we can consider it is unlikely the score will improve by much.\r\n- Despite above example hit miss optimization do not affect scoring of exact match (sub-string or acronym)\r\n- There are some legitimate use for hit miss, for example while scoring query `Mississippi` each positive match for `s` or `i` may trigger up to 3 hit miss on the other occurrence of that letter in query.\r\n\r\n- For that reason, we propose counting consecutive hit miss and having a maximum of one hit miss per character of the subject.\r\n\r\n**Q:** Does this grantee improvement over leftmost alignment?\r\n**A:** It'll often be the case but no guarantee on pathological matches.\r\n For example, in query `abcde` against candidate '**abc**abcabcabcabcabcabczde' we may trigger the miss count before matching `de`. It'll still be registered as a match and probably a good one with `abc` at the start, `de` will be scored as optional characters not present.\r\n\r\nCandidate  'abcabcabcabcabcabc**abcde**' will not have any problem because it does not affect exact match.\r\n\r\nA real world example is searching `index` in the benchmark. Where `i`, `n`, `d`, `e` exist scattered in folder name, but x exist in the extension `.txt`. However, the whole point of this project is to prefer structured match to scattered one so this might not be a problem.\r\n\r\n### High Positive count mitigation\r\n**[option `maxInners`, disabled by default]**\r\n\r\nA lot of the speed of this PR come from the idea that rejection happens often, and we need to be very efficient on them to offset slower higher quality match. Unfortunately, some query will match against almost everything.\r\n\r\n- Fast short-circuit path for exact substring acronym help a lot.\r\n- Missed hit heuristic also help a lot for general purpose match.\r\n\r\nHowever, we may still be too slow for interactive time query on large data set. This is why `maxInners` option is provided.\r\n\r\nThis is the maximum number of positive candidate we collect before sorting and returning the list.\r\n\r\nThe realization is that a query that match everything on a 50K item data set is unlikely to show anything useful to the user above the fold (say in the first 15 results).\r\n\r\nSo then the priority is to detect such case of low quality (low discrimination power) query and report fast to the user so user can refine its query.\r\n\r\nA `maxInners` size of about 20% of the list works well. It is not needed on a smaller list.\r\n\r\n### Active Region Optimization\r\n\r\nBefore the first occurrence of the first char of query in the subject, or after the last occurrence of the last char of query in the subject it is impossible to make a match. So we'll trim the subject to that active region. The search for those boundaries is linear while the optimal alignment algorithm is quadratic, so it is an improvement, however, little or large we move.\r\n\r\n### Benchmark\r\n- All test compare this PR to previous version (legacy)\r\n\r\n- The first test `index` is a typical use case, 10% positive, 1/3 of positive are exact matches.\r\n  - We are about 2x faster\r\n\r\n- Second test `indx` remove exact matches. Just under 2x faster\r\n\r\n- Third test `walkdr`, 1% positive, mostly testing `isMatch()`, above 2x faster.\r\n\r\n- Fourth test `node`, exact match, 98% positive, bit under 2x faster.\r\n\r\n- Test 5 `nm`, exact acronym match, 98% positive, about 10% slower.\r\n\r\n- Test 6 `nodemodules` is special in that it use a string that score on almost every candidate, often multiple time per candidate and individuals characters are popular. It also avoid exact match speed-up. About 2x slower, but unlikely to happens in real life. `maxInners` mitigation cover that case.\r\n\r\n\r\n````\r\nFiltering 66672 entries for 'index' took 62ms for 6168 results (~10% of results are positive, mix exact & fuzzy)\r\nFiltering 66672 entries for 'index' took 120ms for 6168 results (~10% of results are positive, Legacy method)\r\n======\r\nFiltering 66672 entries for 'indx' took 69ms for 6192 results (~10% of results are positive, Fuzzy match)\r\nFiltering 66672 entries for 'indx' took 126ms for 6192 results (~10% of results are positive, Fuzzy match, Legacy)\r\n======\r\nFiltering 66672 entries for 'walkdr' took 30ms for 504 results (~1% of results are positive, fuzzy)\r\nFiltering 66672 entries for 'walkdr' took 70ms for 504 results (~1% of results are positive, Legacy method)\r\n======\r\nFiltering 66672 entries for 'node' took 112ms for 65136 results (~98% of results are positive, mostly Exact match)\r\nFiltering 66672 entries for 'node' took 213ms for 65136 results (~98% of results are positive, mostly Exact match, Legacy method)\r\n======\r\nFiltering 66672 entries for 'nm' took 60ms for 65208 results (~98% of results are positive, Acronym match)\r\nFiltering 66672 entries for 'nm' took 56ms for 65208 results (~98% of results are positive, Acronym match, Legacy method)\r\n======\r\nFiltering 66672 entries for 'nodemodules' took 602ms for 65124 results (~98% positive + Fuzzy match, [Worst case scenario])\r\nFiltering 66672 entries for 'nodemodules' took 123ms for 13334 results (~98% positive + Fuzzy match, [Mitigation])\r\nFiltering 66672 entries for 'nodemodules' took 295ms for 65124 results (Legacy)\r\n````\r\n\r\n**Q:** My results are not as good.\r\n**A:** Run the benchmark a few time, it looks like some optimization kick in later. (Or CPU on energy efficient device might need to warm up before some optimization are activated)\r\n\r\n\r\n\r\n## Prior Art\r\n\r\n[Chrome FilePathScore](https://chromium.googlesource.com/chromium/blink/+/master/Source/devtools/front_end/sources/FilePathScoreFunction.js#70)\r\n\r\n[Textmate ranker](https://github.com/textmate/textmate/blob/master/Frameworks/text/src/ranker.cc#L46)\r\n\r\n[VIM Command-T ](https://github.com/wincent/command-t/blob/master/ruby/command-t/match.c#L22)\r\n\r\n[Selecta](https://github.com/garybernhardt/selecta/blob/master/selecta#L415)\r\n\r\n[PeepOpen](https://github.com/topfunky/PeepOpen/blob/master/Classes/Models/FuzzyRecord.rb)\r\n\r\n[flx](https://github.com/lewang/flx)\r\n\r\n\r\n## List of addressed issues\r\n\r\n### Exact match vs directory depth.\r\n\r\nhttps://github.com/atom/fuzzaldrin/issues/18\r\n-> actionsServiceSpec\r\n\r\nhttps://github.com/atom/atom/issues/7783\r\n-> usa_spec\r\n\r\n### Start of string VS directory depth\r\n\r\nhttps://github.com/atom/fuzzy-finder/issues/57#issuecomment-133531653\r\n-> notification\r\n\r\nhttps://github.com/atom/fuzzy-finder/issues/21#issuecomment-48795958\r\n-> video backbone\r\n\r\n### Folder / file query\r\n\r\nhttps://github.com/atom/fuzzy-finder/issues/21#issue-29106280\r\n-> src/app vs destroy_discard\r\n\r\nhttps://github.com/atom/fuzzy-finder/issues/21#issuecomment-46920333\r\n-> email handler\r\n\r\nhttps://github.com/substantial/atomfiles/issues/43\r\n-> model user\r\n\r\n### Spread/group vs directory depth\r\n\r\nhttps://github.com/atom/fuzzy-finder/issues/21#issuecomment-138664303\r\n-> controller core\r\n\r\n### Initialism\r\n\r\nhttps://github.com/atom/fuzzy-finder/issues/57#issue-42120886\r\n-> itc switch / ImportanceTableCtrl\r\n\r\nhttps://github.com/atom/fuzzy-finder/issues/57#issuecomment-95623924\r\n-> application controller\r\n\r\nhttps://github.com/atom/fuzzaldrin/issues/21\r\n-> fft vs FilterFactorTests\r\n\r\n### Accidental Acronym\r\n\r\nhttps://github.com/atom/command-palette/issues/28\r\n-> Install / Find Select All\r\n\r\nhttps://github.com/atom/fuzzaldrin/issues/20#issue-93279352\r\n-> Git Plus Stage Hunk / Git Plus Push\r\n\r\n\r\n### Case sensitivity\r\n\r\nhttps://github.com/atom/autocomplete-plus/issues/42\r\n-> downloadThread / DownloadTask\r\n\r\nhttps://github.com/atom/fuzzaldrin/issues/17\r\n-> diagnostics / Diagnostic\r\n\r\n\r\n### Optional Characters\r\n\r\nhttps://github.com/atom/fuzzy-finder/issues/91\r\nhttps://github.com/atom/fuzzaldrin/issues/24\r\n\r\n-> PHP Namespaces, let \"\\\" match \"/\"\r\n-> (would be nice for config file in mixed OS environment too)\r\n\r\nhttps://github.com/atom/fuzzy-finder/pull/51\r\n\r\n-> Ruby Namespaces, let \"::\" match \"/\"\r\n\r\nhttps://github.com/atom/fuzzy-finder/issues/10\r\n-> SpaceRegex, let \" \" match \"/\"\r\n-> was already implemented, posted here to show parallel.\r\n\r\n\r\n### Suggestions\r\n\r\nhttps://github.com/atom/fuzzy-finder/issues/21#issue-29106280\r\n-> we implement suggestion of score based on run length\r\n-> todo allows fuzzaldrin to support external knowledge.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}