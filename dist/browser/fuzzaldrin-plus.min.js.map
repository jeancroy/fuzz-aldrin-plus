{"version":3,"sources":["webpack:///fuzzaldrin-plus.min.js","webpack:///webpack/bootstrap 20b13ee611feb7305af6","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/scorer.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/pathScorer.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/definitions/defaultOptions.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/definitions/filterState.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/fuzzaldrin-plus.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/env.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/filter.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/matcher.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/query.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/utils.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","score","string","preparedQuery","options","allowErrors","isMatch","core_lw","core_up","string_lw","toLowerCase","computeScore","Math","ceil","subject","query_lw","query_up","length","n","i","j","qj_lw","charCodeAt","qj_up","si","subject_lw","query","flexUppercase","strictUpperCase","current_score","acro","scoreAcronyms","acro_score","count","scoreExact","pos","indexOf","scoreExactMatch","score_row","Array","csc_row","sz","scoreSize","miss_budget","miss_coeff","miss_left","mm","lastIndexOf","csc_invalid","si_lw","charCodes","score_diag","csc_diag","record_miss","score_up","csc_score","qj","start","isWordStart","scoreConsecutives","align_score","scoreCharacter","curr_s","prev_s","isSeparator","isWordEnd","len","next_s","scorePosition","pos_bonus","sc","max","tau_size","abs","quality","wm","scorePattern","sameCase","end","bonus","posBonus","startOfWord","mi","nj","k","pos2","emptyAcronymResult","sepCount","sumPos","fullWord","isAcronymFullWord","AcronymResult","nbAcronymInQuery","__esModule","default","this","_scorer","scorePath","fullPathScore","useExtensionBonus","pathSeparator","basePos","fileLength","extAdjust","getExtensionScore","ext","depth","basePathScore","slice","alpha","tau_depth","countDir","file_coeff","path","getExtension","str","substr","candidate","startPos","endPos","maxDepth","matched","getDefaults","env","defaultPathSeparator","queryOptions","optCharRegEx","scoringOptions","extend","usePathScoring","filterOptions","key","maxResults","outputScore","matchOptions","wrapOptions","tagOpen","tagClose","tagClass","reference","target","hasOwnProperty","Object","prototype","FilterState","isPending","cancelRequest","discardResults","scoredCandidates","scoreProvider","accessor","FilterResult","state","cancel","keepResults","arguments","undefined","isCanceled","getProgress","filter","candidates","checkString","checkCollection","parseOptions","defaultOptions","getPreparedQuery","_filter","filterSync","filterAsync","callback","_pathScorer","match","range","idx","_matcher","wrap","prepareQuery","obj","size","_defaultOptions","preparedQueryCache","_query","Query","_env","fuzzaldrin","isBrowser","window","_typeof","Symbol","iterator","constructor","isNode","process","toString","platform","_interopRequireDefault","_filterState","executeFilter","internalState","filterResult","scheduled","setImmediate","setTimeout","_utils2","isFunction","x","processCollection","sort","sortCandidates","map","pluckCandidates","collection","isArray","processItem","getIterator","item","next","isIteratorItem","done","value","cont","forEach","context","push","a","b","_scorer2","_pathScorer2","_utils","matches","computeMatch","baseMatches","basenameMatch","mergeMatches","replace","matchPositions","nbMatches","output","matchIndex","strPos","matchPos","substring","bj","out","ai","offset","STOP","UP","LEFT","DIAGONAL","trace","move","align","backtrack","reverse","coreChars","opt_char_re","truncatedUpperCase","upper","_iterator","_isArray","_i","_ref","char","toUpperCase","getCharCodes","core","fn","tentativeArray","object","REAL_ITERATOR_SYMBOL","FAUX_ITERATOR_SYMBOL"],"mappings":"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","file":"fuzzaldrin-plus.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(5);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.score = score;\n\texports.isMatch = isMatch;\n\texports.computeScore = computeScore;\n\texports.isWordStart = isWordStart;\n\texports.isWordEnd = isWordEnd;\n\texports.isSeparator = isSeparator;\n\texports.scorePosition = scorePosition;\n\texports.scoreSize = scoreSize;\n\texports.scoreExact = scoreExact;\n\texports.scorePattern = scorePattern;\n\texports.scoreCharacter = scoreCharacter;\n\texports.scoreConsecutives = scoreConsecutives;\n\texports.scoreExactMatch = scoreExactMatch;\n\texports.scoreAcronyms = scoreAcronyms;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t//\n\t// Score similarity between two string\n\t//\n\t//  isMatch: Fast detection if all character of needle is in haystack\n\t//  score: Find string similarity using a Smith Waterman algorithm\n\t//         Modified to account for programing scenarios (CamelCase folder/file.ext object.property)\n\t//\n\t// Copyright (C) 2015 Jean Christophe Roy and contributors\n\t// MIT License: http://opensource.org/licenses/MIT\n\t\n\t\n\t// Base point for a single character match\n\t// This balance making patterns VS position and size penalty.\n\tvar wm = 150;\n\t\n\t//Fading function\n\tvar pos_bonus = 20; // The character from 0..pos_bonus receive a greater bonus for being at the init of string.\n\tvar tau_size = 85; // Full path length at which the whole match score is halved.\n\t\n\t// Miss count\n\t// When subject[i] is query[j] we register a hit.\n\t// Limiting hit put a boundary on how many permutation we consider to find the best one.\n\t// Helps to speed-up processing of long path and query containing frequent character (eg vowels)\n\t//\n\t// If a spec with frequent repetition fail, increase this.\n\t// This has a direct influence on worst case scenario benchmark.\n\tvar miss_coeff = 0.75; //Max number missed consecutive hit = ceil(miss_coeff*query.length) + 5\n\t\n\t\n\t//\n\t// Main export\n\t//\n\t\n\texports.default = {\n\t\n\t    score: score,\n\t    isMatch: isMatch\n\t\n\t};\n\t\n\t\n\t// Manage the logic of testing if there's a match and calling the main scoring function\n\t// Also manage scoring a path and optional character.\n\t\n\t/**\n\t *\n\t * @param {string} string\n\t * @param {Query} preparedQuery\n\t * @param {ScoringOptions} options\n\t * @returns {number}\n\t */\n\tfunction score(string, preparedQuery, options) {\n\t    var allowErrors = options.allowErrors;\n\t\n\t    if (!allowErrors && !isMatch(string, preparedQuery.core_lw, preparedQuery.core_up)) {\n\t        return 0;\n\t    }\n\t    var string_lw = string.toLowerCase();\n\t    var score = computeScore(string, string_lw, preparedQuery, options);\n\t    return Math.ceil(score);\n\t}\n\t\n\t//\n\t// isMatch:\n\t// Are all (non optional)characters of query in subject, in proper order ?\n\t//\n\t\n\tfunction isMatch(subject, query_lw, query_up) {\n\t    var m = subject.length;\n\t    var n = query_lw.length;\n\t\n\t    if (!m || n > m) {\n\t        return false;\n\t    }\n\t\n\t    var i = -1;\n\t    var j = -1;\n\t\n\t    //foreach char of query\n\t    while (++j < n) {\n\t\n\t        var qj_lw = query_lw.charCodeAt(j);\n\t        var qj_up = query_up.charCodeAt(j);\n\t\n\t        // Continue walking the subject from where we have left with previous query char\n\t        // until we have found a character that is either lowercase or uppercase query.\n\t        while (++i < m) {\n\t            var si = subject.charCodeAt(i);\n\t            if (si === qj_lw || si === qj_up) {\n\t                break;\n\t            }\n\t        }\n\t\n\t        // If we passed the last char, query is not in subject\n\t        if (i === m) {\n\t            return false;\n\t        }\n\t    }\n\t\n\t    // Found every char of query in subject in proper order, match is positive\n\t    return true;\n\t}\n\t\n\t//----------------------------------------------------------------------\n\t//\n\t// Main scoring algorithm\n\t//\n\t\n\t/**\n\t *\n\t * @param {string} subject\n\t * @param {string} subject_lw\n\t * @param {Query} preparedQuery\n\t * @param {ScoringOptions} options\n\t * @returns {*}\n\t */\n\tfunction computeScore(subject, subject_lw, preparedQuery, options) {\n\t    var query = preparedQuery.query,\n\t        query_lw = preparedQuery.query_lw;\n\t\n\t    var flexUppercase = !options.strictUpperCase;\n\t\n\t    var m = subject.length;\n\t    var n = query.length;\n\t    var current_score = 0;\n\t\n\t    //----------------------------\n\t    // Abbreviations sequence\n\t\n\t    var acro = scoreAcronyms(subject, subject_lw, query, query_lw);\n\t    var acro_score = acro.score;\n\t\n\t    // Whole query is abbreviation ?\n\t    // => use that as score\n\t    if (acro.count === n) {\n\t        return scoreExact(n, m, acro_score, acro.pos);\n\t    }\n\t\n\t    //----------------------------\n\t    // Exact Match ?\n\t    // => use that as score\n\t\n\t    var pos = subject_lw.indexOf(query_lw);\n\t    if (pos > -1) {\n\t        return scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m);\n\t    }\n\t\n\t    //----------------------------\n\t    // Individual characters\n\t    // (Smith Waterman algorithm)\n\t\n\t\n\t    //Init\n\t    var score_row = new Array(n);\n\t    var csc_row = new Array(n);\n\t    var sz = scoreSize(n, m);\n\t\n\t    var miss_budget = Math.ceil(miss_coeff * n) + 5;\n\t    var miss_left = miss_budget;\n\t\n\t    //Fill with 0\n\t    var j = -1;\n\t    while (++j < n) {\n\t        score_row[j] = 0;\n\t        csc_row[j] = 0;\n\t    }\n\t\n\t    // Limit the search to the isPending region\n\t    // for example with query `abc`, subject `____a_bc_ac_c____`\n\t    // there's a region before first `a` and after last `c`\n\t    // that can be simplified out of the matching process\n\t\n\t    // Before first occurrence in subject of first letter of query, or -1\n\t    var i = subject_lw.indexOf(query_lw[0]);\n\t    if (i > -1) {\n\t        i--;\n\t    }\n\t\n\t    // After last occurrence of last letter of query,\n\t    var mm = subject_lw.lastIndexOf(query_lw[n - 1], m);\n\t    if (mm > i) {\n\t        m = mm + 1;\n\t    }\n\t\n\t    var csc_invalid = true;\n\t\n\t    while (++i < m) {\n\t        //foreach char si of subject\n\t\n\t        var si_lw = subject_lw[i];\n\t\n\t        // if si_lw is not in query\n\t        if (preparedQuery.charCodes[si_lw.charCodeAt(0)] == null) {\n\t            // reset csc_row and move to next\n\t            if (csc_invalid !== true) {\n\t                j = -1;\n\t                while (++j < n) {\n\t                    csc_row[j] = 0;\n\t                }\n\t                csc_invalid = true;\n\t            }\n\t            continue;\n\t        }\n\t\n\t        var si = subject_lw[i];\n\t\n\t        current_score = 0;\n\t        var score_diag = 0;\n\t        var csc_diag = 0;\n\t        var record_miss = true;\n\t        csc_invalid = false;\n\t\n\t        j = -1; //0..n-1\n\t        while (++j < n) {\n\t            //foreach char qj of query\n\t\n\t            // What is the best gap ?\n\t            // score_up contain the score of a gap in subject.\n\t            // score_left = last iteration of score, -> gap in query.\n\t            var score_up = score_row[j];\n\t            if (score_up > current_score) {\n\t                current_score = score_up;\n\t            }\n\t\n\t            //Reset consecutive\n\t            var csc_score = 0;\n\t            var qj_lw = query_lw[j];\n\t\n\t            // Compute a tentative match\n\t            // First check case-insesitive match\n\t            if (qj_lw === si_lw) {\n\t\n\t                // Refine for strict Uppercase\n\t                //\n\t                // When do we have a match ?\n\t                // A) Case Insensitive Match && Not strict Uppercase\n\t                // B) Case Insensitive Match && Query is lowercase\n\t                // C) Case Sensitive Match. (Imply Case Insensitive)\n\t\n\t                var qj = query[j];\n\t                if (flexUppercase || qj_lw === qj || si === qj) {\n\t\n\t                    var start = isWordStart(i, subject, subject_lw);\n\t\n\t                    // Forward search for a sequence of consecutive char\n\t                    csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);\n\t\n\t                    // Determine bonus for matching A[i] with B[j]\n\t                    var align_score = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);\n\t\n\t                    //Are we better using this match or taking the best gap (currently stored in score)?\n\t                    if (align_score > current_score) {\n\t                        current_score = align_score;\n\t                        // reset consecutive missed hit count\n\t                        miss_left = miss_budget;\n\t                    } else {\n\t                        // We rejected this match and record a miss.\n\t                        // If budget is exhausted exit\n\t                        if (record_miss && --miss_left <= 0) {\n\t                            return score_row[n - 1] * sz;\n\t                        }\n\t                        record_miss = false;\n\t                    }\n\t                }\n\t            }\n\t\n\t            //Prepare next sequence & match score.\n\t            score_diag = score_up;\n\t            csc_diag = csc_row[j];\n\t            csc_row[j] = csc_score;\n\t            score_row[j] = current_score;\n\t        }\n\t    }\n\t\n\t    // get highest score so far\n\t    current_score = score_row[n - 1];\n\t    return current_score * sz;\n\t}\n\t\n\t//\n\t// Boundaries\n\t//\n\t// Is the character at the init of a word, end of the word, or a separator ?\n\t// Fortunately those small function inline well.\n\t//\n\t\n\tfunction isWordStart(pos, subject, subject_lw) {\n\t    if (pos === 0) {\n\t        return true;\n\t    } // match is FIRST char ( place a virtual token separator before first char of string)\n\t    var curr_s = subject[pos];\n\t    var prev_s = subject[pos - 1];\n\t    return isSeparator(prev_s) || // match FOLLOW a separator\n\t    curr_s !== subject_lw[pos] && prev_s === subject_lw[pos - 1]; // match is Capital in camelCase (preceded by lowercase)\n\t}\n\t\n\tfunction isWordEnd(pos, subject, subject_lw, len) {\n\t    if (pos === len - 1) {\n\t        return true;\n\t    } // last char of string\n\t    var curr_s = subject[pos];\n\t    var next_s = subject[pos + 1];\n\t    return isSeparator(next_s) || // match IS FOLLOWED BY a separator\n\t    curr_s === subject_lw[pos] && next_s !== subject_lw[pos + 1]; // match is lowercase, followed by uppercase\n\t}\n\t\n\tfunction isSeparator(c) {\n\t    return c === ' ' || c === '.' || c === '-' || c === '_' || c === '/' || c === '\\\\';\n\t}\n\t//\n\t// Scoring helper\n\t//\n\t\n\tfunction scorePosition(pos) {\n\t    if (pos < pos_bonus) {\n\t        var sc = pos_bonus - pos;\n\t        return 100 + sc * sc;\n\t    } else {\n\t        return Math.max(100 + pos_bonus - pos, 0);\n\t    }\n\t}\n\t\n\tfunction scoreSize(n, m) {\n\t    // Size penalty, use the difference of size (m-n)\n\t    return tau_size / (tau_size + Math.abs(m - n));\n\t}\n\t\n\tfunction scoreExact(n, m, quality, pos) {\n\t    return 2 * n * (wm * quality + scorePosition(pos)) * scoreSize(n, m);\n\t}\n\t\n\t//\n\t// Shared scoring logic between exact match, consecutive & acronym\n\t// Ensure pattern length dominate the score then refine to take into account case-sensitivity\n\t// and structural quality of the pattern on the overall string (word boundary)\n\t//\n\t\n\tfunction scorePattern(count, len, sameCase, start, end) {\n\t    var sz = count;\n\t\n\t    var bonus = 6; // to ensure consecutive length dominate score, this should be as large other bonus combined\n\t    if (sameCase === count) {\n\t        bonus += 2;\n\t    }\n\t    if (start) {\n\t        bonus += 3;\n\t    }\n\t    if (end) {\n\t        bonus += 1;\n\t    }\n\t\n\t    if (count === len) {\n\t        // when we match 100% of query we allow to break the size ordering.\n\t        // This is to help exact match bubble up vs size, depth penalty etc\n\t        if (start) {\n\t            if (sameCase === len) {\n\t                sz += 2;\n\t            } else {\n\t                sz += 1;\n\t            }\n\t        }\n\t        if (end) {\n\t            bonus += 1;\n\t        }\n\t    }\n\t\n\t    return sameCase + sz * (sz + bonus);\n\t}\n\t\n\t//\n\t// Compute the bonuses for two chars that are confirmed to matches in a case-insensitive way\n\t//\n\t\n\tfunction scoreCharacter(i, j, start, acro_score, csc_score) {\n\t\n\t    // init of string / position of match bonus\n\t    var posBonus = scorePosition(i);\n\t\n\t    // match IS a word boundary\n\t    // choose between taking part of consecutive characters or consecutive acronym\n\t    if (start) {\n\t        return posBonus + wm * ((acro_score > csc_score ? acro_score : csc_score) + 10);\n\t    }\n\t\n\t    // normal Match\n\t    return posBonus + wm * csc_score;\n\t}\n\t\n\t//\n\t// Forward search for a sequence of consecutive character.\n\t//\n\t\n\tfunction scoreConsecutives(subject, subject_lw, query, query_lw, i, j, startOfWord) {\n\t    var m = subject.length;\n\t    var n = query.length;\n\t\n\t    var mi = m - i;\n\t    var nj = n - j;\n\t    var k = mi < nj ? mi : nj;\n\t\n\t    var sameCase = 0;\n\t\n\t    // query_lw[i] is subject_lw[j] has been checked before entering now do case sensitive check.\n\t    if (query[j] === subject[i]) {\n\t        sameCase++;\n\t    }\n\t\n\t    // size of consecutive\n\t    // sz will be one more than the last index where query[j] == subject[i] (lowercase)\n\t    var sz = 0;\n\t\n\t    //Continue while lowercase char are the same, record when they are case-sensitive match.\n\t    while (++sz < k && query_lw[++j] === subject_lw[++i]) {\n\t        if (query[j] === subject[i]) {\n\t            sameCase++;\n\t        }\n\t    }\n\t\n\t    // Faster path for single match.\n\t    // Isolated character match occurs often and are not really interesting.\n\t    // Fast path so we don't compute expensive pattern score on them.\n\t    // Acronym should be addressed with acronym context bonus instead of consecutive.\n\t    if (sz === 1) {\n\t        return 1 + 2 * sameCase;\n\t    }\n\t\n\t    return scorePattern(sz, n, sameCase, startOfWord, isWordEnd(i, subject, subject_lw, m));\n\t}\n\t\n\t//\n\t// Compute the score of an exact match at position pos.\n\t//\n\t\n\tfunction scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m) {\n\t\n\t    // Test for word init\n\t    var start = isWordStart(pos, subject, subject_lw);\n\t\n\t    // Heuristic\n\t    // If not a word init, test next occurrence\n\t    // - We want exact match to be fast\n\t    // - For exact match, word init has the biggest impact on score.\n\t    // - Testing 2 instances is somewhere between testing only one and testing every instances.\n\t\n\t    if (!start) {\n\t        var pos2 = subject_lw.indexOf(query_lw, pos + 1);\n\t        if (pos2 > -1) {\n\t            start = isWordStart(pos2, subject, subject_lw);\n\t            if (start) {\n\t                pos = pos2;\n\t            }\n\t        }\n\t    }\n\t\n\t    //Exact case bonus.\n\t    var i = -1;\n\t    var sameCase = 0;\n\t    while (++i < n) {\n\t        if (query[pos + i] === subject[i]) {\n\t            sameCase++;\n\t        }\n\t    }\n\t\n\t    var end = isWordEnd(pos + n - 1, subject, subject_lw, m);\n\t\n\t    return scoreExact(n, m, scorePattern(n, n, sameCase, start, end), pos);\n\t}\n\t\n\t//\n\t// Acronym prefix\n\t//\n\t\n\t\n\tvar AcronymResult = function AcronymResult(score, pos, count) {\n\t    _classCallCheck(this, AcronymResult);\n\t\n\t    this.score = score;\n\t    this.pos = pos;\n\t    this.count = count;\n\t};\n\t\n\tvar emptyAcronymResult = new AcronymResult(0, 0.1, 0);\n\t\n\tfunction scoreAcronyms(subject, subject_lw, query, query_lw) {\n\t    var m = subject.length;\n\t    var n = query.length;\n\t\n\t    //a single char is not an acronym\n\t    if (m <= 1 || n <= 1) {\n\t        return emptyAcronymResult;\n\t    }\n\t\n\t    var count = 0;\n\t    var sepCount = 0;\n\t    var sumPos = 0;\n\t    var sameCase = 0;\n\t\n\t    var i = -1;\n\t    var j = -1;\n\t\n\t    //foreach char of query\n\t    while (++j < n) {\n\t\n\t        var qj_lw = query_lw[j];\n\t\n\t        // Separator will not score point but will continue the prefix when present.\n\t        // Test that the separator is in the candidate and advance cursor to that position.\n\t        // If no separator break the prefix\n\t\n\t        if (isSeparator(qj_lw)) {\n\t            i = subject_lw.indexOf(qj_lw, i + 1);\n\t            if (i > -1) {\n\t                sepCount++;\n\t                continue;\n\t            } else {\n\t                break;\n\t            }\n\t        }\n\t\n\t        // For other characters we search for the first match where subject[i] = query[j]\n\t        // that also happens to be a init-of-word\n\t\n\t        while (++i < m) {\n\t            if (qj_lw === subject_lw[i] && isWordStart(i, subject, subject_lw)) {\n\t                if (query[j] === subject[i]) {\n\t                    sameCase++;\n\t                }\n\t                sumPos += i;\n\t                count++;\n\t                break;\n\t            }\n\t        }\n\t\n\t        // All of subject is consumed, stop processing the query.\n\t        if (i === m) {\n\t            break;\n\t        }\n\t    }\n\t\n\t    // Here, all of query is consumed (or we have reached a character not in acronym)\n\t    // A single character is not an acronym (also prevent division by 0)\n\t    if (count < 2) {\n\t        return emptyAcronymResult;\n\t    }\n\t\n\t    // Acronym are scored as init-of-word\n\t    // Unless the acronym is a 1:1 match with candidate then it is upgraded to full-word.\n\t    var fullWord = count === n ? isAcronymFullWord(subject, subject_lw, query, count) : false;\n\t    var score = scorePattern(count, n, sameCase, true, fullWord);\n\t\n\t    return new AcronymResult(score, sumPos / count, count + sepCount);\n\t}\n\t\n\t//\n\t// Test whether there's a 1:1 relationship between query and acronym of candidate.\n\t// For that to happens\n\t// (a) All character of query must be matched to an acronym of candidate\n\t// (b) All acronym of candidate must be matched to a character of query.\n\t//\n\t// This method check for (b) assuming (a) has been checked before entering.\n\t\n\tfunction isAcronymFullWord(subject, subject_lw, query, nbAcronymInQuery) {\n\t    var m = subject.length;\n\t    var n = query.length;\n\t    var count = 0;\n\t\n\t    // Heuristic:\n\t    // Assume one acronym every (at most) 12 character on average\n\t    // This filter out long paths, but then they can match on the filename.\n\t    if (m > 12 * n) {\n\t        return false;\n\t    }\n\t\n\t    var i = -1;\n\t    while (++i < m) {\n\t        //For each char of subject\n\t        //Test if we have an acronym, if so increase acronym count.\n\t        //If the acronym count is more than nbAcronymInQuery (number of non separator char in query)\n\t        //Then we do not have 1:1 relationship.\n\t        if (isWordStart(i, subject, subject_lw) && ++count > nbAcronymInQuery) {\n\t            return false;\n\t        }\n\t    }\n\t\n\t    return true;\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.score = score;\n\texports.countDir = countDir;\n\texports.getExtension = getExtension;\n\texports.getExtensionScore = getExtensionScore;\n\t\n\tvar _scorer = __webpack_require__(1);\n\t\n\tvar tau_depth = 13; //  Directory depth at which the full path influence is halved.\n\tvar file_coeff = 1.2; //  Full path is also penalized for length of basename. This adjust a scale factor for that penalty.\n\t\n\texports.default = {\n\t    score: score,\n\t    countDir: countDir,\n\t    getExtensionScore: getExtensionScore\n\t};\n\t\n\t//  Manage the logic of testing if there's a match and calling the main scoring function\n\t//  Also manage scoring a path and optional character.\n\t\n\t/**\r\n\t *\r\n\t * @param {string} string\r\n\t * @param {Query} preparedQuery\r\n\t * @param {ScoringOptions} options\r\n\t * @returns {number}\r\n\t */\n\t\n\tfunction score(string, preparedQuery, options) {\n\t    var allowErrors = options.allowErrors;\n\t\n\t    if (!allowErrors && !(0, _scorer.isMatch)(string, preparedQuery.core_lw, preparedQuery.core_up)) {\n\t        return 0;\n\t    }\n\t    var string_lw = string.toLowerCase();\n\t    var score = (0, _scorer.computeScore)(string, string_lw, preparedQuery, options);\n\t    score = scorePath(string, string_lw, score, preparedQuery, options);\n\t    return Math.ceil(score);\n\t}\n\t\n\t// \n\t//  Score adjustment for path\n\t// \n\t\n\tfunction scorePath(subject, subject_lw, fullPathScore, preparedQuery, options) {\n\t\n\t    if (fullPathScore === 0) {\n\t        return 0;\n\t    }\n\t\n\t    var useExtensionBonus = options.useExtensionBonus,\n\t        pathSeparator = options.pathSeparator;\n\t\n\t    //  Skip trailing slashes\n\t\n\t    var end = subject.length - 1;\n\t    while (subject[end] === pathSeparator) {\n\t        end--;\n\t    }\n\t\n\t    //  Get position of basePath of subject.\n\t    var basePos = subject.lastIndexOf(pathSeparator, end);\n\t    var fileLength = end - basePos;\n\t\n\t    //  Get a bonus for matching extension\n\t    var extAdjust = 1.0;\n\t\n\t    if (useExtensionBonus) {\n\t        extAdjust += getExtensionScore(subject_lw, preparedQuery.ext, basePos, end, 2);\n\t        fullPathScore *= extAdjust;\n\t    }\n\t\n\t    //  no basePath, nothing else to compute.\n\t    if (basePos === -1) {\n\t        return fullPathScore;\n\t    }\n\t\n\t    //  Get the number of folder in query\n\t    var depth = preparedQuery.depth;\n\t\n\t    //  Get that many folder from subject\n\t\n\t    while (basePos > -1 && depth-- > 0) {\n\t        basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\n\t    }\n\t\n\t    //  Get basePath score, if BaseName is the whole string, no need to recompute\n\t    //  We still need to apply the folder depth and filename penalty.\n\t    var basePathScore = basePos === -1 ? fullPathScore : extAdjust * (0, _scorer.computeScore)(subject.slice(basePos + 1, end + 1), subject_lw.slice(basePos + 1, end + 1), preparedQuery, options);\n\t\n\t    //  Final score is linear interpolation between base score and full path score.\n\t    //  For low directory depth, interpolation favor base Path then include more of full path as depth increase\n\t    //\n\t    //  A penalty based on the size of the basePath is applied to fullPathScore\n\t    //  That way, more focused basePath match can overcome longer directory path.\n\t\n\t    var alpha = 0.5 * tau_depth / (tau_depth + countDir(subject, end + 1, pathSeparator));\n\t    return alpha * basePathScore + (1 - alpha) * fullPathScore * (0, _scorer.scoreSize)(0, file_coeff * fileLength);\n\t}\n\t\n\t// \n\t//  Count number of folder in a path.\n\t//  (consecutive slashes count as a single directory)\n\t// \n\t\n\tfunction countDir(path, end, pathSeparator) {\n\t    if (end < 1) {\n\t        return 0;\n\t    }\n\t\n\t    var count = 0;\n\t    var i = 0;\n\t\n\t    // skip slash at the start of string\n\t    // so `foo/bar` and `/foo/bar` have the same depth.\n\t    while (i < end && path[i] === pathSeparator) {\n\t        i++;\n\t    }\n\t\n\t    // scan for path separator\n\t    while (i < end) {\n\t\n\t        if (path[i] === pathSeparator) {\n\t\n\t            //When path found increase directory depth\n\t            count++;\n\t\n\t            //But treat multiple consecutive pathSeparator as one\n\t            while (i < end && path[i] === pathSeparator) {\n\t                i++;\n\t            }\n\t        }\n\t\n\t        i++;\n\t    }\n\t\n\t    return count;\n\t}\n\t\n\t// \n\t//  Find fraction of extension that is matched by query.\n\t//  For example mf.h prefers myFile.h to myfile.html\n\t//  This need special handling because it give point for not having characters (the `tml` in above example)\n\t// \n\t\n\tfunction getExtension(str) {\n\t    var pos = str.lastIndexOf(\".\");\n\t    if (pos < 0) {\n\t        return \"\";\n\t    } else {\n\t        return str.substr(pos + 1);\n\t    }\n\t}\n\t\n\tfunction getExtensionScore(candidate, ext, startPos, endPos, maxDepth) {\n\t    //  startPos is the position of last slash of candidate, -1 if absent.\n\t\n\t    if (ext == null || !ext.length) {\n\t        return 0;\n\t    }\n\t\n\t    //  Check that (a) extension exist, (b) it is after the init of the basename\n\t    var pos = candidate.lastIndexOf(\".\", endPos);\n\t    if (pos <= startPos) {\n\t        return 0;\n\t    } //  (note that startPos >= -1)\n\t\n\t    var n = ext.length;\n\t    var m = endPos - pos;\n\t\n\t    //  n contain the smallest of both extension length, m the largest.\n\t    if (m < n) {\n\t        n = m;\n\t        m = ext.length;\n\t    }\n\t\n\t    // place cursor after dot & count number of matching characters in extension\n\t    pos++;\n\t    var matched = -1;\n\t    while (++matched < n) {\n\t        if (candidate[pos + matched] !== ext[matched]) {\n\t            break;\n\t        }\n\t    }\n\t\n\t    //  if nothing found, try deeper for multiple extensions, with some penalty for depth\n\t    if (matched === 0 && maxDepth > 0) {\n\t        return 0.9 * getExtensionScore(candidate, ext, startPos, pos - 2, maxDepth - 1);\n\t    }\n\t\n\t    //  cannot divide by zero because m is the largest extension length and we return if either is 0\n\t    return matched / m;\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.getDefaults = getDefaults;\n\texports.extend = extend;\n\t/**\r\n\t *\r\n\t * @param env\r\n\t * @returns {{queryOptions: QueryOptions, scoringOptions: ScoringOptions, filterOptions: FilterOptions, matchOptions: MatchOptions, wrapOptions: WrapOptions}}\r\n\t */\n\t\n\tfunction getDefaults(env) {\n\t\n\t    var defaultPathSeparator = env.defaultPathSeparator;\n\t\n\t    /**\r\n\t     * @typedef {Object} QueryOptions\r\n\t     * @property {string} pathSeparator - If candidate are path, indicate path separator used (usually '/' or '\\\\').\r\n\t     * @property {RegExp} optCharRegEx - Regex that identify character that does not have to match exactly, for example <whitespace>.\r\n\t     *\r\n\t     */\n\t\n\t    /**\r\n\t     * @type {QueryOptions}\r\n\t     */\n\t    var queryOptions = {\n\t        pathSeparator: defaultPathSeparator,\n\t        optCharRegEx: null\n\t    };\n\t\n\t    /**\r\n\t     * @typedef {Object} ScoringOptions\r\n\t     * @extends QueryOptions\r\n\t     *\r\n\t     * @property {boolean} strictUpperCase - With this on, uppercase must be matched by another uppercase.\r\n\t     *                                       With this off, same case is preferred but not mandatory.\r\n\t     * @property {boolean} allowErrors - Should we allow candidates that does not have all characters of query ?\r\n\t     * @property {boolean} usePathScoring - Should we try to interpret candidates as path\r\n\t     * @property {boolean} useExtensionBonus - Should we try to interpret extension from query\r\n\t     *                                         and prefer files that match that extension (needs usePathScoring)\r\n\t     * @property {Query} preparedQuery - If you have a precomputed query object set it here.\r\n\t     */\n\t\n\t    /**\r\n\t     * @type {ScoringOptions}\r\n\t     */\n\t    var scoringOptions = extend(queryOptions, {\n\t        strictUpperCase: false,\n\t        allowErrors: false,\n\t        usePathScoring: true,\n\t        useExtensionBonus: false,\n\t        preparedQuery: null\n\t    });\n\t\n\t    /**\r\n\t     * @typedef {Object} FilterOptions\r\n\t     * @extends ScoringOptions\r\n\t     *\r\n\t     * @property {string|function|null} key - Name of the property that contain string ot be scored\r\n\t     *                                   or function that input candidate and output string to be scored.\r\n\t     *\r\n\t     * @property {number|null} maxResults - Output the top `maxResults` best results at most.\r\n\t     * @property {bool} outputScore - If true output is an array of {candidate,score} else output is an array of candidates\r\n\t     *\r\n\t     */\n\t\n\t    /**\r\n\t     * @type {FilterOptions}\r\n\t     */\n\t    var filterOptions = extend(scoringOptions, {\n\t        key: null,\n\t        maxResults: null,\n\t        outputScore: false\n\t    });\n\t\n\t    /**\r\n\t     * @typedef {Object} MatchOptions\r\n\t     * @extends ScoringOptions\r\n\t     *\r\n\t     */\n\t\n\t    /**\r\n\t     * @type {MatchOptions}\r\n\t     */\n\t    var matchOptions = extend(scoringOptions, {});\n\t\n\t    /**\r\n\t     * @typedef {Object} WrapOptions\r\n\t     * @extends MatchOptions\r\n\t     *\r\n\t     * @property {string} tagOpen - string to place before a match default to `<strong class=\"highlight\">`\r\n\t     * @property {string} tagClose - string to place after a match default to `</strong>`\r\n\t     * @property {string} tagClass - change the class of the default open tag (tagOpen must be unset)\r\n\t     *\r\n\t     */\n\t\n\t    /**\r\n\t     * @type {WrapOptions}\r\n\t     */\n\t    var wrapOptions = extend(matchOptions, {\n\t        tagOpen: '<strong class=\"{tagClass}\">',\n\t        tagClose: '</strong>',\n\t        tagClass: 'highlight'\n\t    });\n\t\n\t    return {\n\t        queryOptions: queryOptions,\n\t        scoringOptions: scoringOptions,\n\t        filterOptions: filterOptions,\n\t        matchOptions: matchOptions,\n\t        wrapOptions: wrapOptions\n\t    };\n\t}\n\t\n\tfunction extend(reference, target) {\n\t\n\t    var hasOwnProperty = Object.prototype.hasOwnProperty;\n\t    for (var key in reference) {\n\t        if (hasOwnProperty.call(reference, key) && !hasOwnProperty.call(target, key)) {\n\t            target[key] = reference[key];\n\t        }\n\t    }\n\t\n\t    return target;\n\t}\n\t\n\texports.default = {\n\t    getDefaults: getDefaults,\n\t    extend: extend\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar FilterState = exports.FilterState = function FilterState() {\n\t    _classCallCheck(this, FilterState);\n\t\n\t    // Filter result mechanic\n\t    this.isPending = true;\n\t    this.cancelRequest = false;\n\t    this.discardResults = false;\n\t    this.count = 0;\n\t\n\t    // Specific to scoring\n\t    this.scoredCandidates = null;\n\t    this.scoreProvider = null;\n\t    this.accessor = null;\n\t};\n\t\n\t/**\r\n\t * @typedef {Object} FilterResult\r\n\t *\r\n\t * @method  cancel - stop scoring and return no results.\r\n\t * @method  isCanceled - has the filter been canceled.\r\n\t * @method  isPending - filter is in progress or haven't started.\r\n\t * @method  getProgress - get the count of processed elements.\r\n\t *\r\n\t */\n\t\n\tvar FilterResult =\n\t\n\t/**\r\n\t * @param {FilterState} state\r\n\t */\n\t\n\texports.FilterResult = function FilterResult(state) {\n\t    _classCallCheck(this, FilterResult);\n\t\n\t    // Closure over the internal state to avoid manual changes.\n\t\n\t    this.cancel = function cancel() {\n\t        var keepResults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t        state.isPending = false;\n\t        state.cancelRequest = true;\n\t        state.discardResults = !keepResults;\n\t    };\n\t\n\t    this.isCanceled = function isCanceled() {\n\t        return state.cancelRequest;\n\t    };\n\t\n\t    this.isPending = function isPending() {\n\t        return state.isPending;\n\t    };\n\t\n\t    this.getProgress = function getProgress() {\n\t        return state.count;\n\t    };\n\t};\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.filter = filter;\n\texports.filterAsync = filterAsync;\n\texports.score = score;\n\texports.match = match;\n\texports.wrap = wrap;\n\texports.prepareQuery = prepareQuery;\n\t\n\tvar _filter = __webpack_require__(7);\n\t\n\tvar _scorer = __webpack_require__(1);\n\t\n\tvar _pathScorer = __webpack_require__(2);\n\t\n\tvar _matcher = __webpack_require__(8);\n\t\n\tvar _query = __webpack_require__(9);\n\t\n\tvar _defaultOptions = __webpack_require__(3);\n\t\n\tvar _env = __webpack_require__(6);\n\t\n\tvar defaultOptions = (0, _defaultOptions.getDefaults)(_env.env);\n\t\n\tvar fuzzaldrin = {\n\t    filter: filter,\n\t    score: score,\n\t    match: match,\n\t    wrap: wrap,\n\t    prepareQuery: prepareQuery,\n\t    defaultOptions: defaultOptions\n\t};\n\t\n\texports.default = fuzzaldrin;\n\t\n\t// Export main object to global window.\n\t\n\tif (_env.env.isBrowser) {\n\t    window.fuzzaldrin = fuzzaldrin;\n\t}\n\t\n\tvar preparedQueryCache = null;\n\t\n\t/**\r\n\t * Filter:\r\n\t *  Given a list of candidate, output a list of candidate that match query.\r\n\t *  Output list is the same format (string or object) than input list.\r\n\t *\r\n\t *  If given a list of object, specify options.key as the property `candidate[key]`\r\n\t *  that contain the string representation of the candidate\r\n\t *\r\n\t *  Output is sorted by match score.\r\n\t *\r\n\t * @param {Array.<(string|object)>|Iterable} candidates - array of string or objects\r\n\t * @param {string} query - string to search for in each candidate\r\n\t * @param {FilterOptions=} options - (optional) see option hash doc\r\n\t * @returns {Array.<(string|object)>} - filtered & sorted subset of input candidates\r\n\t */\n\t\n\tfunction filter(candidates, query, options) {\n\t\n\t    if (!checkString(query)) return [];\n\t    if (!checkCollection(candidates)) return [];\n\t\n\t    options = parseOptions(options, defaultOptions.filterOptions);\n\t    var preparedQuery = getPreparedQuery(query, options);\n\t\n\t    return (0, _filter.filterSync)(candidates, preparedQuery, options);\n\t}\n\t\n\t/**\r\n\t *\r\n\t * @param candidates\r\n\t * @param query\r\n\t * @param options\r\n\t * @param {filterCallback} callback\r\n\t * @returns {FilterResult}\r\n\t */\n\t\n\tfunction filterAsync(candidates, query, callback, options) {\n\t\n\t    if (!checkString(query)) return [];\n\t    if (!checkCollection(candidates)) return [];\n\t\n\t    options = parseOptions(options, defaultOptions.filterOptions);\n\t    var preparedQuery = getPreparedQuery(query, options);\n\t\n\t    return (0, _filter.filterAsync)(candidates, preparedQuery, callback, options);\n\t}\n\t\n\t/**\r\n\t * Score:\r\n\t *   Give the numerical score on how a given string match query.\r\n\t *\r\n\t *   This is provided so you can build your own filter method.\r\n\t *   For example you may have a special way to iterate candidate,\r\n\t *   access candidate string representation, or you may need to\r\n\t *   modify the score to account external knowledge (eg last modified date)\r\n\t *\r\n\t * @param {string} string - string representation of a candidate\r\n\t * @param {string} query - string to search for in candidate\r\n\t * @param {ScoringOptions=} options - (optional) see option hash doc\r\n\t * @returns {number} score 0 .. max, where max is score(string, string)\r\n\t */\n\t\n\tfunction score(string, query, options) {\n\t\n\t    if (!checkString(string)) return 0;\n\t    if (!checkString(query)) return 0;\n\t\n\t    options = parseOptions(options, defaultOptions.scoringOptions);\n\t    var preparedQuery = getPreparedQuery(query, options);\n\t\n\t    if (options.usePathScoring) {\n\t        return (0, _pathScorer.score)(string, preparedQuery, options);\n\t    } else {\n\t        return (0, _scorer.score)(string, preparedQuery, options);\n\t    }\n\t}\n\t\n\t/**\r\n\t * Match:\r\n\t *    Communicate which characters of candidate where selected by the algorithm to represent the query.\r\n\t *    The match function output an array of character position.\r\n\t *    If you need to display those character as an html string see wrap function.\r\n\t *\r\n\t * @param {string} string - string representation of a candidate\r\n\t * @param {string} query - string to search for in candidate\r\n\t * @param {MatchOptions=} options (optional)\r\n\t * @returns {Array.<number>}\r\n\t */\n\t\n\tfunction match(string, query, options) {\n\t\n\t    if (!checkString(string)) return [];\n\t    if (!checkString(query)) return [];\n\t\n\t    //If both are the same, return an array of consecutive numbers\n\t    if (string === query) {\n\t        var length = string.length;\n\t        var range = new Array(length);\n\t        for (var idx = 0; idx < length; idx++) {\n\t            range[idx] = idx;\n\t        }\n\t        return range;\n\t    }\n\t\n\t    options = parseOptions(options, defaultOptions.matchOptions);\n\t    var preparedQuery = getPreparedQuery(query, options);\n\t\n\t    return (0, _matcher.match)(string, preparedQuery, options);\n\t}\n\t\n\t/**\r\n\t * Wrap:\r\n\t *    Communicate which characters of candidate where selected by the algorithm to represent the query.\r\n\t *    This function output the given string with chosen character wrapped in a delimiter string (eg html tag).\r\n\t *\r\n\t *    To control the wrap use the option hash.\r\n\t *    Here are some default value:\r\n\t *      options.tagOpen = `<strong class=\"highlight\">`\r\n\t *      options.tagClose = `</strong>`\r\n\t *\r\n\t *    Alternatively, if you chose to keep the default tagOpen,\r\n\t *    you can specify option.tagClass and change the `highlight`\r\n\t *    class to one of your choosing.\r\n\t *\r\n\t *    Wrap method will try to group consecutive matches under the same tag.\r\n\t *\r\n\t * @param {string} string - string representation of a candidate\r\n\t * @param {string} query - string to search for in candidate\r\n\t * @param {WrapOptions=} options\r\n\t * @returns {string} - input string with match wrapped in open and close tag.\r\n\t */\n\t\n\tfunction wrap(string, query, options) {\n\t\n\t    if (!checkString(string)) return \"\";\n\t    if (!checkString(query)) return string;\n\t\n\t    options = parseOptions(options, defaultOptions.wrapOptions);\n\t    var preparedQuery = getPreparedQuery(query, options);\n\t\n\t    return (0, _matcher.wrap)(string, query, options);\n\t}\n\t\n\t/**\r\n\t * PrepareQuery:\r\n\t *   The usual scenario is to compare a single query with multiple candidate.\r\n\t *   To speed that process up, we pre-compute some information about the query.\r\n\t *\r\n\t *   Pre-computed query is natural to use in bulk method like filter, but harder\r\n\t *   in one-by-one method like score or match. To keep those method fast you can give\r\n\t *   a pre computed query in option hash as `options.preparedQuery`\r\n\t *\r\n\t *   Note that we use an internal cache `preparedQueryCache` that cover most of the simple cases\r\n\t *   So this method may not be needed in thos cases.\r\n\t *\r\n\t * @param {string} query\r\n\t * @param {QueryOptions} options\r\n\t * @returns {Query}\r\n\t */\n\t\n\tfunction prepareQuery(query, options) {\n\t    options = parseOptions(options);\n\t    return getPreparedQuery(query, options);\n\t}\n\t\n\tfunction checkString(str) {\n\t    //Not null, must have length property > 0\n\t    return str != null && str.length != null && str.length > 0;\n\t}\n\t\n\tfunction checkCollection(obj) {\n\t    // Not null\n\t    // If object has length or size property, must be != 0\n\t    // Example of thing with size: (es6 sets, ImmutableJs collections)\n\t    return obj != null && obj.length !== 0 && obj.size !== 0;\n\t}\n\t\n\t//\n\t// Setup default values\n\t//\n\t\n\t\n\tfunction parseOptions(options, defaultOptions) {\n\t\n\t    // If no options given, copy default\n\t    // Else merge options with defaults.\n\t    if (options == null) options = {};\n\t    return (0, _defaultOptions.extend)(defaultOptions, options);\n\t}\n\t\n\tfunction getPreparedQuery(query, options) {\n\t\n\t    // If prepared query in option hash is valid, use it\n\t    if (options.preparedQuery != null && options.preparedQuery.query === query) return options.preparedQuery;\n\t\n\t    // Recompute cache if empty or invalid\n\t    if (preparedQueryCache == null || preparedQueryCache.query !== query) {\n\t        preparedQueryCache = new _query.Query(query, options);\n\t    }\n\t\n\t    // Serve from cache\n\t    return preparedQueryCache;\n\t}\n\t\n\t//\n\t// Async\n\t//\n\t\n\t/**\r\n\t * @callback filterCallback\r\n\t * @param {Array} results\r\n\t * @param {FilterResult} state\r\n\t */\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t//\n\t// Detect node.js or browser to set default path separator\n\t//\n\t\n\tvar isNode = (typeof process === 'undefined' ? 'undefined' : _typeof(process)) === 'object' && Object.prototype.toString.call(process) === '[object process]';\n\tvar isBrowser = !isNode && (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && Object.prototype.toString.call(window) === \"[object Window]\";\n\t\n\t// On node js we assume the list of candidates match local OS path format.\n\t// While on browser assume that we are dealing with url\n\t// Use 'options.pathSeparator' if you need a behavior different from those assumptions.\n\tvar defaultPathSeparator = isNode && process.platform === \"win32\" ? \"\\\\\" : \"/\";\n\t\n\tvar env = exports.env = {\n\t    isNode: isNode,\n\t    isBrowser: isBrowser,\n\t    defaultPathSeparator: defaultPathSeparator\n\t};\n\t\n\texports.default = {\n\t    env: env\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.filterSync = filterSync;\n\texports.filterAsync = filterAsync;\n\t\n\tvar _scorer = __webpack_require__(1);\n\t\n\tvar _scorer2 = _interopRequireDefault(_scorer);\n\t\n\tvar _pathScorer = __webpack_require__(2);\n\t\n\tvar _pathScorer2 = _interopRequireDefault(_pathScorer);\n\t\n\tvar _utils = __webpack_require__(10);\n\t\n\tvar _utils2 = _interopRequireDefault(_utils);\n\t\n\tvar _filterState = __webpack_require__(4);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t    filterSync: filterSync,\n\t    filterAsync: filterAsync\n\t};\n\t\n\t/**\r\n\t *\r\n\t * @param {Array|Iterable} candidates\r\n\t * @param {Query} preparedQuery\r\n\t * @param {FilterOptions} options\r\n\t * @returns {Array}\r\n\t */\n\t\n\tfunction filterSync(candidates, preparedQuery, options) {\n\t    var state = new _filterState.FilterState();\n\t    return executeFilter(candidates, preparedQuery, state, options);\n\t}\n\t\n\t/**\r\n\t *\r\n\t * @param {Array|Iterable} candidates\r\n\t * @param {Query} preparedQuery\r\n\t * @param {FilterOptions} options\r\n\t * @param {filterCallback} callback\r\n\t * @returns {FilterResult}\r\n\t */\n\t\n\tfunction filterAsync(candidates, preparedQuery, callback, options) {\n\t\n\t    var internalState = new _filterState.FilterState();\n\t    var filterResult = new _filterState.FilterResult(internalState);\n\t\n\t    var scheduled = function scheduled() {\n\t        callback(executeFilter(candidates, preparedQuery, internalState, options), filterResult);\n\t    };\n\t\n\t    if (typeof setImmediate === \"function\") {\n\t        setImmediate(scheduled);\n\t    } else {\n\t        setTimeout(scheduled, 0);\n\t    }\n\t\n\t    return filterResult;\n\t}\n\t\n\t/**\r\n\t *\r\n\t * @param {Array|Iterable} candidates\r\n\t * @param {Query} preparedQuery\r\n\t * @param {FilterState} state\r\n\t * @param {FilterOptions} options\r\n\t * @returns {Array}\r\n\t */\n\t\n\tfunction executeFilter(candidates, preparedQuery, state, options) {\n\t\n\t    if (state.cancelRequest) return [];\n\t\n\t    // See option parsing on main module for default\n\t    var key = options.key,\n\t        maxResults = options.maxResults,\n\t        outputScore = options.outputScore,\n\t        usePathScoring = options.usePathScoring;\n\t\n\t    // If list of object, we need to get the string to be scored, as defined by options.key\n\t    // If the key is a method, that method should take an object and return the string.\n\t    // Else we assume it is the name of a property on candidate object.\n\t\n\t    var accessor = null;\n\t    if (key != null) {\n\t        accessor = _utils2.default.isFunction(options.key) ? options.key : function (x) {\n\t            return x[key];\n\t        };\n\t    }\n\t\n\t    // Init state\n\t    state.isPending = true;\n\t    state.accessor = accessor;\n\t    state.scoreProvider = usePathScoring ? _pathScorer2.default : _scorer2.default;\n\t    state.scoredCandidates = [];\n\t\n\t    // Iterate candidate list and collect scored positive matches.\n\t    processCollection(candidates, preparedQuery, state, options);\n\t\n\t    // Collect positives matches\n\t    var scoredCandidates = state.scoredCandidates;\n\t\n\t    // Cleanup\n\t    state.scoredCandidates = null;\n\t    state.isPending = false;\n\t\n\t    // Quick exit\n\t    if (state.discardResults || scoredCandidates == null || !scoredCandidates.length) return [];\n\t\n\t    // Sort scores in descending order\n\t    scoredCandidates.sort(sortCandidates);\n\t\n\t    // Trim to maxResults if specified\n\t    if (maxResults != null) {\n\t        scoredCandidates = scoredCandidates.slice(0, maxResults);\n\t    }\n\t\n\t    // Return either a sorted list of candidate or list of candidate-score pairs.\n\t    if (outputScore === true) {\n\t        return scoredCandidates;\n\t    } else {\n\t        // Extract original candidate and return\n\t        return scoredCandidates.map(pluckCandidates);\n\t    }\n\t}\n\t\n\tfunction processCollection(collection, preparedQuery, state, options) {\n\t\n\t    //\n\t    // Collection is an array\n\t    //\n\t\n\t    if (_utils2.default.isArray(collection)) {\n\t        for (var i = 0; i <= collection.length; i++) {\n\t            if (!processItem(collection[i], preparedQuery, state, options)) break;\n\t        }\n\t        return true;\n\t    }\n\t\n\t    //\n\t    // Collection is an Iterable or Iterator (es6 protocol)\n\t    //\n\t\n\t    var iterator = _utils2.default.getIterator(collection);\n\t    if (iterator != null) {\n\t        var item = iterator.next();\n\t        if (_utils2.default.isIteratorItem(item)) {\n\t            while (!item.done) {\n\t                if (!processItem(item.value, preparedQuery, state, options)) break;\n\t                item = iterator.next();\n\t            }\n\t            return true;\n\t        }\n\t    }\n\t\n\t    //\n\t    // Collection implements 'forEach'\n\t    //\n\t\n\t    // Some implementations  of foreach allow to exit using return false. (Eg Immutablejs)\n\t    //      processItem follow that convention .\n\t    //\n\t    // Others cannot be interrupted ( Eg default Array.forEach )\n\t    //      so we continue iteration but short circuit most of the work.\n\t\n\t    var cont = true;\n\t    if (_utils2.default.isFunction(collection.forEach)) {\n\t        collection.forEach(function (item) {\n\t            return cont = cont && processItem(item, preparedQuery, state, options);\n\t        });\n\t        return true;\n\t    }\n\t\n\t    return false;\n\t}\n\t\n\t/**\r\n\t *\r\n\t * @param {string|object} candidate\r\n\t * @param {Query} preparedQuery\r\n\t * @param {FilterState} context\r\n\t * @param {FilterOptions} options\r\n\t * @returns {boolean}\r\n\t */\n\t\n\tfunction processItem(candidate, preparedQuery, context, options) {\n\t\n\t    if (context.cancelRequest) return false;\n\t    context.count++;\n\t\n\t    var accessor = context.accessor,\n\t        scoredCandidates = context.scoredCandidates,\n\t        scoreProvider = context.scoreProvider;\n\t\n\t    // Get the string representation of candidate\n\t\n\t    var string = accessor != null ? accessor(candidate) : candidate;\n\t    if (string == null || !string.length) return true;\n\t\n\t    // Get score, If score greater than 0 add to valid results\n\t    var score = scoreProvider.score(string, preparedQuery, options);\n\t    if (score > 0) scoredCandidates.push({ candidate: candidate, score: score });\n\t\n\t    return true;\n\t}\n\t\n\tfunction pluckCandidates(a) {\n\t    return a.candidate;\n\t}\n\t\n\tfunction sortCandidates(a, b) {\n\t    return b.score - a.score;\n\t}\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.match = match;\n\texports.wrap = wrap;\n\t\n\tvar _scorer = __webpack_require__(1);\n\t\n\texports.default = {\n\t    match: match,\n\t    wrap: wrap\n\t};\n\t\n\t// Return position of character which matches\n\t\n\t/**\r\n\t *\r\n\t * @param {string} string\r\n\t * @param {Query} preparedQuery\r\n\t * @param {MatchOptions} options\r\n\t * @returns {Array.<number>}\r\n\t */\n\t// A match list is an array of indexes to characters that match.\n\t// This file should closely follow `scorer` except that it returns an array\n\t// of indexes instead of a score.\n\t\n\tfunction match(string, preparedQuery, options) {\n\t    var allowErrors = options.allowErrors,\n\t        pathSeparator = options.pathSeparator;\n\t\n\t\n\t    if (!allowErrors && !(0, _scorer.isMatch)(string, preparedQuery.core_lw, preparedQuery.core_up)) {\n\t        return [];\n\t    }\n\t    var string_lw = string.toLowerCase();\n\t\n\t    // Full path results\n\t    var matches = computeMatch(string, string_lw, preparedQuery);\n\t\n\t    //if there is no matches on the full path, there should not be any on the base path either.\n\t    if (matches.length === 0) {\n\t        return matches;\n\t    }\n\t\n\t    // Is there a base path ?\n\t    if (string.indexOf(pathSeparator) > -1) {\n\t\n\t        // Base path results\n\t        var baseMatches = basenameMatch(string, string_lw, preparedQuery, pathSeparator);\n\t\n\t        // Combine the results, removing duplicate indexes\n\t        matches = mergeMatches(matches, baseMatches);\n\t    }\n\t\n\t    return matches;\n\t}\n\t\n\t//\n\t// Wrap\n\t//\n\t// Helper around match if you want a string with result wrapped by some delimiter text\n\t\n\t/**\r\n\t *\r\n\t * @param {string} string\r\n\t * @param {Query} preparedQuery\r\n\t * @param {WrapOptions} options\r\n\t * @returns {*}\r\n\t */\n\tfunction wrap(string, preparedQuery, options) {\n\t    var tagClass = options.tagClass,\n\t        tagOpen = options.tagOpen,\n\t        tagClose = options.tagClose;\n\t\n\t\n\t    if (tagOpen && tagOpen.length) {\n\t        tagOpen = tagOpen.replace(\"{tagClass}\", tagClass);\n\t    }\n\t\n\t    if (string === preparedQuery.query) {\n\t        return tagOpen + string + tagClose;\n\t    }\n\t\n\t    //Run get position where a match is found\n\t    var matchPositions = match(string, preparedQuery, options);\n\t    var nbMatches = matchPositions.length;\n\t\n\t    //If no match return as is\n\t    if (nbMatches === 0) {\n\t        return string;\n\t    }\n\t\n\t    //Loop over match positions\n\t    var output = '';\n\t    var matchIndex = -1;\n\t    var strPos = 0;\n\t    while (++matchIndex < nbMatches) {\n\t        var matchPos = matchPositions[matchIndex];\n\t\n\t        // Get text before the current match position\n\t        if (matchPos > strPos) {\n\t            output += string.substring(strPos, matchPos);\n\t            strPos = matchPos;\n\t        }\n\t\n\t        // Get consecutive matches to wrap under a single tag\n\t        while (++matchIndex < nbMatches) {\n\t            if (matchPositions[matchIndex] === matchPos + 1) {\n\t                matchPos++;\n\t            } else {\n\t                matchIndex--;\n\t                break;\n\t            }\n\t        }\n\t\n\t        //Get text inside the match, including current character\n\t        matchPos++;\n\t        if (matchPos > strPos) {\n\t            output += tagOpen;\n\t            output += string.substring(strPos, matchPos);\n\t            output += tagClose;\n\t            strPos = matchPos;\n\t        }\n\t    }\n\t\n\t    //Get string after last match\n\t    if (strPos < string.length - 1) {\n\t        output += string.substring(strPos);\n\t    }\n\t\n\t    //return wrapped text\n\t    return output;\n\t}\n\t\n\tfunction basenameMatch(subject, subject_lw, preparedQuery, pathSeparator) {\n\t\n\t    // Skip trailing slashes\n\t    var end = subject.length - 1;\n\t    while (subject[end] === pathSeparator) {\n\t        end--;\n\t    }\n\t\n\t    // Get position of basePath of subject.\n\t    var basePos = subject.lastIndexOf(pathSeparator, end);\n\t\n\t    //If no PathSeparator, no base path exist.\n\t    if (basePos === -1) {\n\t        return [];\n\t    }\n\t\n\t    // Get the number of folder in query\n\t    var depth = preparedQuery.depth;\n\t\n\t    // Get that many folder from subject\n\t\n\t    while (depth-- > 0) {\n\t        basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\n\t        if (basePos === -1) {\n\t            return [];\n\t        }\n\t    } //consumed whole subject ?\n\t\n\t    // Get basePath match\n\t    basePos++;\n\t    end++;\n\t    return computeMatch(subject.slice(basePos, end), subject_lw.slice(basePos, end), preparedQuery, basePos);\n\t}\n\t\n\t//\n\t// Combine two matches result and remove duplicate\n\t// (Assume sequences are sorted, matches are sorted by construction.)\n\t//\n\t\n\tfunction mergeMatches(a, b) {\n\t    var m = a.length;\n\t    var n = b.length;\n\t\n\t    if (n === 0) {\n\t        return a.slice();\n\t    }\n\t    if (m === 0) {\n\t        return b.slice();\n\t    }\n\t\n\t    var i = -1;\n\t    var j = 0;\n\t    var bj = b[j];\n\t    var out = [];\n\t\n\t    while (++i < m) {\n\t        var ai = a[i];\n\t\n\t        while (bj <= ai && ++j < n) {\n\t            if (bj < ai) {\n\t                out.push(bj);\n\t            }\n\t            bj = b[j];\n\t        }\n\t\n\t        out.push(ai);\n\t    }\n\t\n\t    while (j < n) {\n\t        out.push(b[j++]);\n\t    }\n\t\n\t    return out;\n\t}\n\t\n\t//----------------------------------------------------------------------\n\t\n\t//\n\t// Align sequence (used for fuzzaldrin.match)\n\t// Return position of subject characters that match query.\n\t//\n\t// Follow closely scorer.computeScore.\n\t// Except at each step we record what triggered the best score.\n\t// Then we trace back to output matched characters.\n\t//\n\t// Differences are:\n\t// - we record the best move at each position in a matrix, and finish by a traceback.\n\t// - we reset consecutive sequence if we do not take the match.\n\t// - no hit miss limit\n\t\n\t\n\tfunction computeMatch(subject, subject_lw, preparedQuery) {\n\t    var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\t    var query = preparedQuery.query;\n\t    var query_lw = preparedQuery.query_lw;\n\t\n\t\n\t    var m = subject.length;\n\t    var n = query.length;\n\t\n\t    //this is like the consecutive bonus, but for camelCase / snake_case initials\n\t    var acro_score = (0, _scorer.scoreAcronyms)(subject, subject_lw, query, query_lw).score;\n\t\n\t    //Init\n\t    var score_row = new Array(n);\n\t    var csc_row = new Array(n);\n\t\n\t    // Directions constants\n\t    var STOP = 0;\n\t    var UP = 1;\n\t    var LEFT = 2;\n\t    var DIAGONAL = 3;\n\t\n\t    //Traceback matrix\n\t    var trace = new Array(m * n);\n\t    var pos = -1;\n\t\n\t    //Fill with 0\n\t    var j = -1; //0..n-1\n\t    while (++j < n) {\n\t        score_row[j] = 0;\n\t        csc_row[j] = 0;\n\t    }\n\t\n\t    var move = void 0;\n\t    var score_diag = void 0;\n\t    var score = void 0;\n\t    var score_up = void 0;\n\t    var csc_diag = void 0;\n\t\n\t    var i = -1; //0..m-1\n\t    while (++i < m) {\n\t        //foreach char si of subject\n\t\n\t        score = 0;\n\t        score_up = 0;\n\t        csc_diag = 0;\n\t\n\t        var si_lw = subject_lw[i];\n\t\n\t        j = -1; //0..n-1\n\t        while (++j < n) {\n\t            //foreach char qj of query\n\t\n\t            //reset score\n\t            var csc_score = 0;\n\t            var align = 0;\n\t            score_diag = score_up;\n\t\n\t            //Compute a tentative match\n\t            if (query_lw[j] === si_lw) {\n\t\n\t                var start = (0, _scorer.isWordStart)(i, subject, subject_lw);\n\t\n\t                // Forward search for a sequence of consecutive char\n\t                csc_score = csc_diag > 0 ? csc_diag : (0, _scorer.scoreConsecutives)(subject, subject_lw, query, query_lw, i, j, start);\n\t\n\t                // Determine bonus for matching A[i] with B[j]\n\t                align = score_diag + (0, _scorer.scoreCharacter)(i, j, start, acro_score, csc_score);\n\t            }\n\t\n\t            //Prepare next sequence & match score.\n\t            score_up = score_row[j]; // Current score_up is next run score diag\n\t            csc_diag = csc_row[j];\n\t\n\t            //In case of equality, moving UP get us closer to the init of the candidate string.\n\t            if (score > score_up) {\n\t                move = LEFT;\n\t            } else {\n\t                score = score_up;\n\t                move = UP;\n\t            }\n\t\n\t            // Only take alignment if it's the absolute best option.\n\t            if (align > score) {\n\t                score = align;\n\t                move = DIAGONAL;\n\t            } else {\n\t                //If we do not take this character, break consecutive sequence.\n\t                // (when consecutive is 0, it'll be recomputed)\n\t                csc_score = 0;\n\t            }\n\t\n\t            score_row[j] = score;\n\t            csc_row[j] = csc_score;\n\t            trace[++pos] = score > 0 ? move : STOP;\n\t        }\n\t    }\n\t\n\t    // -------------------\n\t    // Go back in the trace matrix\n\t    // and collect matches (diagonals)\n\t\n\t    i = m - 1;\n\t    j = n - 1;\n\t    pos = i * n + j;\n\t    var backtrack = true;\n\t    var matches = [];\n\t\n\t    while (backtrack && i >= 0 && j >= 0) {\n\t        switch (trace[pos]) {\n\t            case UP:\n\t                i--;\n\t                pos -= n;\n\t                break;\n\t            case LEFT:\n\t                j--;\n\t                pos--;\n\t                break;\n\t            case DIAGONAL:\n\t                matches.push(i + offset);\n\t                j--;\n\t                i--;\n\t                pos -= n + 1;\n\t                break;\n\t            default:\n\t                backtrack = false;\n\t        }\n\t    }\n\t\n\t    matches.reverse();\n\t    return matches;\n\t}\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.Query = undefined;\n\t\n\tvar _pathScorer = __webpack_require__(2);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } //\n\t// Query object\n\t//\n\t// Allow to reuse some quantities computed from query.\n\t// Optional char can optionally be specified in the form of a regular expression.\n\t//\n\t\n\t\n\tvar Query =\n\t\n\t/**\r\n\t *\r\n\t * @param {string} query\r\n\t * @param {QueryOptions} options\r\n\t */\n\texports.Query = function Query(query, options) {\n\t    _classCallCheck(this, Query);\n\t\n\t    if (query == null || !query.length) {\n\t        return;\n\t    }\n\t\n\t    this.query = query;\n\t    this.query_lw = query.toLowerCase();\n\t    this.core = coreChars(query, options.optCharRegEx);\n\t    this.core_lw = this.core.toLowerCase();\n\t    this.core_up = truncatedUpperCase(this.core);\n\t    this.depth = (0, _pathScorer.countDir)(query, query.length, options.pathSeparator);\n\t    this.ext = (0, _pathScorer.getExtension)(this.query_lw);\n\t    this.charCodes = getCharCodes(this.query_lw);\n\t};\n\t\n\t//\n\t// Optional chars\n\t// Those char improve the score if present, but will not block the match (score=0) if absent.\n\t\n\tvar opt_char_re = /[ _\\-:\\/\\\\]/g;\n\t\n\t/**\r\n\t *\r\n\t * @param {string} query\r\n\t * @param {RegExp} optCharRegEx\r\n\t * @returns {string}\r\n\t */\n\tfunction coreChars(query, optCharRegEx) {\n\t\n\t    if (optCharRegEx == null) {\n\t        optCharRegEx = opt_char_re;\n\t    }\n\t\n\t    return query.replace(optCharRegEx, '');\n\t}\n\t\n\t//\n\t// Truncated Upper Case:\n\t// --------------------\n\t//\n\t// A fundamental mechanic is that we are able to keep uppercase and lowercase variant of the strings in sync.\n\t// For that we assume uppercase and lowercase version of the string have the same length.\n\t// Of course unicode being unicode there's exceptions.\n\t// See ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt for the list\n\t//\n\t// \"Strae\".toUpperCase() -> \"STRASSE\"\n\t// truncatedUpperCase(\"Strae\") -> \"STRASE\"\n\t// iterating over every character, getting uppercase variant and getting first char of that.\n\t//\n\t\n\tfunction truncatedUpperCase(str) {\n\t    var upper = \"\";\n\t    for (var _iterator = str, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n\t        var _ref;\n\t\n\t        if (_isArray) {\n\t            if (_i >= _iterator.length) break;\n\t            _ref = _iterator[_i++];\n\t        } else {\n\t            _i = _iterator.next();\n\t            if (_i.done) break;\n\t            _ref = _i.value;\n\t        }\n\t\n\t        var char = _ref;\n\t\n\t        upper += char.toUpperCase()[0];\n\t    }\n\t    return upper;\n\t}\n\t\n\t//\n\t// Get character codes:\n\t// --------------------\n\t//\n\t// Get character codes map for a given string\n\t//\n\t\n\tfunction getCharCodes(str) {\n\t    var len = str.length;\n\t    var i = -1;\n\t\n\t    var charCodes = [];\n\t    // create map\n\t    while (++i < len) {\n\t        charCodes[str.charCodeAt(i)] = true;\n\t    }\n\t\n\t    return charCodes;\n\t}\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\texports.isFunction = isFunction;\n\texports.isArray = isArray;\n\texports.getIterator = getIterator;\n\texports.isIteratorItem = isIteratorItem;\n\texports.default = {\n\t    isFunction: isFunction,\n\t    isArray: isArray,\n\t    getIterator: getIterator,\n\t    isIteratorItem: isIteratorItem\n\t};\n\tfunction isFunction(fn) {\n\t    return typeof fn === \"function\";\n\t}\n\t\n\tfunction isArray(tentativeArray) {\n\t\n\t    if (isFunction(Array.isArray)) {\n\t        return Array.isArray(tentativeArray);\n\t    }\n\t\n\t    return Object.prototype.toString.call(tentativeArray) === \"[object Array]\";\n\t}\n\t\n\t//\n\t// Es6 compatible iterator.\n\t// Follow convention of ImmutableJS\n\t//\n\t\n\tvar REAL_ITERATOR_SYMBOL = typeof Symbol === \"function\" && _typeof(Symbol.iterator) === \"symbol\" ? Symbol.iterator : null;\n\tvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\t\n\tfunction getIterator(object) {\n\t\n\t    if (object == null) return null;\n\t\n\t    // Get iterator from Iterable\n\t    var iterator = null;\n\t    if (REAL_ITERATOR_SYMBOL != null && isFunction(object[REAL_ITERATOR_SYMBOL])) {\n\t        // real es6 Iterable\n\t        iterator = object[REAL_ITERATOR_SYMBOL]();\n\t    } else if (isFunction(object[REAL_ITERATOR_SYMBOL])) {\n\t        // es < 6 fallback.\n\t        iterator = object[FAUX_ITERATOR_SYMBOL]();\n\t    }\n\t\n\t    // Ensure that that iterator implements 'next' function\n\t    if (iterator != null && isFunction(iterator.next)) return iterator;\n\t\n\t    // Test if object itself is iterator-like\n\t    if (isFunction(object.next)) {\n\t        return object;\n\t    }\n\t\n\t    return null;\n\t}\n\t\n\tfunction isIteratorItem(item) {\n\t    return item != null && 'done' in item && 'value' in item;\n\t}\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// fuzzaldrin-plus.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 20b13ee611feb7305af6","//\n// Score similarity between two string\n//\n//  isMatch: Fast detection if all character of needle is in haystack\n//  score: Find string similarity using a Smith Waterman algorithm\n//         Modified to account for programing scenarios (CamelCase folder/file.ext object.property)\n//\n// Copyright (C) 2015 Jean Christophe Roy and contributors\n// MIT License: http://opensource.org/licenses/MIT\n\n\n// Base point for a single character match\n// This balance making patterns VS position and size penalty.\nconst wm = 150;\n\n//Fading function\nconst pos_bonus = 20; // The character from 0..pos_bonus receive a greater bonus for being at the init of string.\nconst tau_size = 85; // Full path length at which the whole match score is halved.\n\n// Miss count\n// When subject[i] is query[j] we register a hit.\n// Limiting hit put a boundary on how many permutation we consider to find the best one.\n// Helps to speed-up processing of long path and query containing frequent character (eg vowels)\n//\n// If a spec with frequent repetition fail, increase this.\n// This has a direct influence on worst case scenario benchmark.\nconst miss_coeff = 0.75; //Max number missed consecutive hit = ceil(miss_coeff*query.length) + 5\n\n\n//\n// Main export\n//\n\nexport default{\n\n    score,\n    isMatch,\n\n    // Other exports from the is* and score* families are available as named exports.\n    // They are used, amongst other things, to sync scorer and matcher behavior\n\n}\n\n\n// Manage the logic of testing if there's a match and calling the main scoring function\n// Also manage scoring a path and optional character.\n\n/**\n *\n * @param {string} string\n * @param {Query} preparedQuery\n * @param {ScoringOptions} options\n * @returns {number}\n */\nexport function score(string, preparedQuery, options) {\n    let {allowErrors} = options;\n    if (!allowErrors && !isMatch(string, preparedQuery.core_lw, preparedQuery.core_up)) {\n        return 0;\n    }\n    let string_lw = string.toLowerCase();\n    let score = computeScore(string, string_lw, preparedQuery, options);\n    return Math.ceil(score);\n}\n\n\n//\n// isMatch:\n// Are all (non optional)characters of query in subject, in proper order ?\n//\n\nexport function isMatch(subject, query_lw, query_up) {\n    let m = subject.length;\n    let n = query_lw.length;\n\n    if (!m || n > m) {\n        return false;\n    }\n\n    let i = -1;\n    let j = -1;\n\n    //foreach char of query\n    while (++j < n) {\n\n        let qj_lw = query_lw.charCodeAt(j);\n        let qj_up = query_up.charCodeAt(j);\n\n        // Continue walking the subject from where we have left with previous query char\n        // until we have found a character that is either lowercase or uppercase query.\n        while (++i < m) {\n            let si = subject.charCodeAt(i);\n            if (si === qj_lw || si === qj_up) {\n                break;\n            }\n        }\n\n        // If we passed the last char, query is not in subject\n        if (i === m) {\n            return false;\n        }\n    }\n\n    // Found every char of query in subject in proper order, match is positive\n    return true;\n}\n\n\n//----------------------------------------------------------------------\n//\n// Main scoring algorithm\n//\n\n/**\n *\n * @param {string} subject\n * @param {string} subject_lw\n * @param {Query} preparedQuery\n * @param {ScoringOptions} options\n * @returns {*}\n */\nexport function computeScore(subject, subject_lw, preparedQuery, options) {\n    let {query, query_lw} = preparedQuery;\n    let flexUppercase = !options.strictUpperCase;\n\n    let m = subject.length;\n    let n = query.length;\n    let current_score = 0;\n\n    //----------------------------\n    // Abbreviations sequence\n\n    let acro = scoreAcronyms(subject, subject_lw, query, query_lw);\n    let acro_score = acro.score;\n\n    // Whole query is abbreviation ?\n    // => use that as score\n    if (acro.count === n) {\n        return scoreExact(n, m, acro_score, acro.pos);\n    }\n\n    //----------------------------\n    // Exact Match ?\n    // => use that as score\n\n    let pos = subject_lw.indexOf(query_lw);\n    if (pos > -1) {\n        return scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m);\n    }\n\n\n    //----------------------------\n    // Individual characters\n    // (Smith Waterman algorithm)\n\n\n    //Init\n    let score_row = new Array(n);\n    let csc_row = new Array(n);\n    let sz = scoreSize(n, m);\n\n    let miss_budget = Math.ceil(miss_coeff * n) + 5;\n    let miss_left = miss_budget;\n\n    //Fill with 0\n    let j = -1;\n    while (++j < n) {\n        score_row[j] = 0;\n        csc_row[j] = 0;\n    }\n\n    // Limit the search to the isPending region\n    // for example with query `abc`, subject `____a_bc_ac_c____`\n    // there's a region before first `a` and after last `c`\n    // that can be simplified out of the matching process\n\n    // Before first occurrence in subject of first letter of query, or -1\n    let i = subject_lw.indexOf(query_lw[0]);\n    if (i > -1) {\n        i--;\n    }\n\n    // After last occurrence of last letter of query,\n    let mm = subject_lw.lastIndexOf(query_lw[n - 1], m);\n    if (mm > i) {\n        m = mm + 1;\n    }\n\n    let csc_invalid = true;\n\n    while (++i < m) {     //foreach char si of subject\n\n        let si_lw = subject_lw[i];\n\n        // if si_lw is not in query\n        if (preparedQuery.charCodes[si_lw.charCodeAt(0)] == null) {\n            // reset csc_row and move to next\n            if (csc_invalid !== true) {\n                j = -1;\n                while (++j < n) {\n                    csc_row[j] = 0;\n                }\n                csc_invalid = true;\n            }\n            continue;\n        }\n\n        let si = subject_lw[i];\n\n        current_score = 0;\n        let score_diag = 0;\n        let csc_diag = 0;\n        let record_miss = true;\n        csc_invalid = false;\n\n        j = -1; //0..n-1\n        while (++j < n) {   //foreach char qj of query\n\n            // What is the best gap ?\n            // score_up contain the score of a gap in subject.\n            // score_left = last iteration of score, -> gap in query.\n            let score_up = score_row[j];\n            if (score_up > current_score) {\n                current_score = score_up;\n            }\n\n            //Reset consecutive\n            let csc_score = 0;\n            let qj_lw = query_lw[j];\n\n\n            // Compute a tentative match\n            // First check case-insesitive match\n            if (qj_lw === si_lw ) {\n\n                // Refine for strict Uppercase\n                //\n                // When do we have a match ?\n                // A) Case Insensitive Match && Not strict Uppercase\n                // B) Case Insensitive Match && Query is lowercase\n                // C) Case Sensitive Match. (Imply Case Insensitive)\n\n                let qj = query[j];\n                if(flexUppercase || qj_lw === qj || si === qj){\n\n                    let start = isWordStart(i, subject, subject_lw);\n\n                    // Forward search for a sequence of consecutive char\n                    csc_score = csc_diag > 0 ? csc_diag :\n                        scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);\n\n                    // Determine bonus for matching A[i] with B[j]\n                    let align_score = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);\n\n                    //Are we better using this match or taking the best gap (currently stored in score)?\n                    if (align_score > current_score) {\n                        current_score = align_score;\n                        // reset consecutive missed hit count\n                        miss_left = miss_budget;\n                    } else {\n                        // We rejected this match and record a miss.\n                        // If budget is exhausted exit\n                        if (record_miss && --miss_left <= 0) {\n                            return score_row[n - 1] * sz;\n                        }\n                        record_miss = false;\n                    }\n                }\n            }\n\n\n            //Prepare next sequence & match score.\n            score_diag = score_up;\n            csc_diag = csc_row[j];\n            csc_row[j] = csc_score;\n            score_row[j] = current_score;\n        }\n    }\n\n    // get highest score so far\n    current_score = score_row[n - 1];\n    return current_score * sz;\n\n}\n\n//\n// Boundaries\n//\n// Is the character at the init of a word, end of the word, or a separator ?\n// Fortunately those small function inline well.\n//\n\nexport function isWordStart(pos, subject, subject_lw) {\n    if (pos === 0) {\n        return true;\n    } // match is FIRST char ( place a virtual token separator before first char of string)\n    let curr_s = subject[pos];\n    let prev_s = subject[pos - 1];\n    return isSeparator(prev_s) || // match FOLLOW a separator\n        (  curr_s !== subject_lw[pos] && prev_s === subject_lw[pos - 1] ); // match is Capital in camelCase (preceded by lowercase)\n}\n\n\nexport function isWordEnd(pos, subject, subject_lw, len) {\n    if (pos === len - 1) {\n        return true;\n    } // last char of string\n    let curr_s = subject[pos];\n    let next_s = subject[pos + 1];\n    return isSeparator(next_s) || // match IS FOLLOWED BY a separator\n        ( curr_s === subject_lw[pos] && next_s !== subject_lw[pos + 1] ); // match is lowercase, followed by uppercase\n}\n\nexport function isSeparator(c) {\n    return c === ' ' || c === '.' || c === '-' || c === '_' || c === '/' || c === '\\\\';\n}\n//\n// Scoring helper\n//\n\nexport function scorePosition(pos) {\n    if (pos < pos_bonus) {\n        let sc = pos_bonus - pos;\n        return 100 + (sc * sc);\n    } else {\n        return Math.max((100 + pos_bonus) - pos, 0);\n    }\n}\n\nexport function scoreSize(n, m) {\n    // Size penalty, use the difference of size (m-n)\n    return tau_size / ( tau_size + Math.abs(m - n))\n}\n\nexport function scoreExact(n, m, quality, pos) {\n    return 2 * n * ( (wm * quality) + scorePosition(pos) ) * scoreSize(n, m);\n}\n\n\n//\n// Shared scoring logic between exact match, consecutive & acronym\n// Ensure pattern length dominate the score then refine to take into account case-sensitivity\n// and structural quality of the pattern on the overall string (word boundary)\n//\n\nexport function scorePattern(count, len, sameCase, start, end) {\n    let sz = count;\n\n    let bonus = 6; // to ensure consecutive length dominate score, this should be as large other bonus combined\n    if (sameCase === count) {\n        bonus += 2;\n    }\n    if (start) {\n        bonus += 3;\n    }\n    if (end) {\n        bonus += 1;\n    }\n\n    if (count === len) {\n        // when we match 100% of query we allow to break the size ordering.\n        // This is to help exact match bubble up vs size, depth penalty etc\n        if (start) {\n            if (sameCase === len) {\n                sz += 2;\n            } else {\n                sz += 1;\n            }\n        }\n        if (end) {\n            bonus += 1;\n        }\n    }\n\n    return sameCase + (sz * ( sz + bonus ));\n}\n\n\n//\n// Compute the bonuses for two chars that are confirmed to matches in a case-insensitive way\n//\n\nexport function scoreCharacter(i, j, start, acro_score, csc_score) {\n\n    // init of string / position of match bonus\n    let posBonus = scorePosition(i);\n\n    // match IS a word boundary\n    // choose between taking part of consecutive characters or consecutive acronym\n    if (start) {\n        return posBonus + (wm * ( (acro_score > csc_score ? acro_score : csc_score) + 10  ));\n    }\n\n    // normal Match\n    return posBonus + (wm * csc_score);\n}\n\n\n//\n// Forward search for a sequence of consecutive character.\n//\n\nexport function scoreConsecutives(subject, subject_lw, query, query_lw, i, j, startOfWord) {\n    let m = subject.length;\n    let n = query.length;\n\n    let mi = m - i;\n    let nj = n - j;\n    let k = mi < nj ? mi : nj;\n\n    let sameCase = 0;\n\n    // query_lw[i] is subject_lw[j] has been checked before entering now do case sensitive check.\n    if (query[j] === subject[i]) {\n        sameCase++;\n    }\n\n    // size of consecutive\n    // sz will be one more than the last index where query[j] == subject[i] (lowercase)\n    let sz = 0;\n\n    //Continue while lowercase char are the same, record when they are case-sensitive match.\n    while (++sz < k && query_lw[++j] === subject_lw[++i]) {\n        if (query[j] === subject[i]) {\n            sameCase++;\n        }\n    }\n\n    // Faster path for single match.\n    // Isolated character match occurs often and are not really interesting.\n    // Fast path so we don't compute expensive pattern score on them.\n    // Acronym should be addressed with acronym context bonus instead of consecutive.\n    if (sz === 1) {\n        return 1 + (2 * sameCase);\n    }\n\n    return scorePattern(sz, n, sameCase, startOfWord, isWordEnd(i, subject, subject_lw, m));\n}\n\n\n//\n// Compute the score of an exact match at position pos.\n//\n\nexport function scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m) {\n\n    // Test for word init\n    let start = isWordStart(pos, subject, subject_lw);\n\n    // Heuristic\n    // If not a word init, test next occurrence\n    // - We want exact match to be fast\n    // - For exact match, word init has the biggest impact on score.\n    // - Testing 2 instances is somewhere between testing only one and testing every instances.\n\n    if (!start) {\n        let pos2 = subject_lw.indexOf(query_lw, pos + 1);\n        if (pos2 > -1) {\n            start = isWordStart(pos2, subject, subject_lw);\n            if (start) {\n                pos = pos2;\n            }\n        }\n    }\n\n    //Exact case bonus.\n    let i = -1;\n    let sameCase = 0;\n    while (++i < n) {\n        if (query[pos + i] === subject[i]) {\n            sameCase++;\n        }\n    }\n\n    let end = isWordEnd((pos + n) - 1, subject, subject_lw, m);\n\n    return scoreExact(n, m, scorePattern(n, n, sameCase, start, end), pos);\n}\n\n\n//\n// Acronym prefix\n//\n\n\nclass AcronymResult {\n    constructor(score, pos, count) {\n        this.score = score;\n        this.pos = pos;\n        this.count = count;\n    }\n}\n\nlet emptyAcronymResult = new AcronymResult(0, 0.1, 0);\n\nexport function scoreAcronyms(subject, subject_lw, query, query_lw) {\n    let m = subject.length;\n    let n = query.length;\n\n    //a single char is not an acronym\n    if (m <= 1 || n <= 1) {\n        return emptyAcronymResult;\n    }\n\n    let count = 0;\n    let sepCount = 0;\n    let sumPos = 0;\n    let sameCase = 0;\n\n    let i = -1;\n    let j = -1;\n\n    //foreach char of query\n    while (++j < n) {\n\n        let qj_lw = query_lw[j];\n\n        // Separator will not score point but will continue the prefix when present.\n        // Test that the separator is in the candidate and advance cursor to that position.\n        // If no separator break the prefix\n\n        if (isSeparator(qj_lw)) {\n            i = subject_lw.indexOf(qj_lw, i + 1);\n            if (i > -1) {\n                sepCount++;\n                continue;\n            } else {\n                break;\n            }\n        }\n\n        // For other characters we search for the first match where subject[i] = query[j]\n        // that also happens to be a init-of-word\n\n        while (++i < m) {\n            if (qj_lw === subject_lw[i] && isWordStart(i, subject, subject_lw)) {\n                if (query[j] === subject[i]) {\n                    sameCase++;\n                }\n                sumPos += i;\n                count++;\n                break;\n            }\n        }\n\n        // All of subject is consumed, stop processing the query.\n        if (i === m) {\n            break;\n        }\n    }\n\n\n    // Here, all of query is consumed (or we have reached a character not in acronym)\n    // A single character is not an acronym (also prevent division by 0)\n    if (count < 2) {\n        return emptyAcronymResult;\n    }\n\n    // Acronym are scored as init-of-word\n    // Unless the acronym is a 1:1 match with candidate then it is upgraded to full-word.\n    let fullWord = count === n ? isAcronymFullWord(subject, subject_lw, query, count) : false;\n    let score = scorePattern(count, n, sameCase, true, fullWord);\n\n    return new AcronymResult(score, sumPos / count, count + sepCount);\n}\n\n\n//\n// Test whether there's a 1:1 relationship between query and acronym of candidate.\n// For that to happens\n// (a) All character of query must be matched to an acronym of candidate\n// (b) All acronym of candidate must be matched to a character of query.\n//\n// This method check for (b) assuming (a) has been checked before entering.\n\nfunction isAcronymFullWord(subject, subject_lw, query, nbAcronymInQuery) {\n    let m = subject.length;\n    let n = query.length;\n    let count = 0;\n\n    // Heuristic:\n    // Assume one acronym every (at most) 12 character on average\n    // This filter out long paths, but then they can match on the filename.\n    if (m > 12 * n) {\n        return false;\n    }\n\n    let i = -1;\n    while (++i < m) {\n        //For each char of subject\n        //Test if we have an acronym, if so increase acronym count.\n        //If the acronym count is more than nbAcronymInQuery (number of non separator char in query)\n        //Then we do not have 1:1 relationship.\n        if (isWordStart(i, subject, subject_lw) && ++count > nbAcronymInQuery) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/scorer.js","import {isMatch, computeScore, scoreSize} from \"./scorer\";\r\n\r\n\r\nconst tau_depth = 13; //  Directory depth at which the full path influence is halved.\r\nconst file_coeff = 1.2; //  Full path is also penalized for length of basename. This adjust a scale factor for that penalty.\r\n\r\nexport default{\r\n    score,\r\n    countDir,\r\n    getExtensionScore\r\n}\r\n\r\n//  Manage the logic of testing if there's a match and calling the main scoring function\r\n//  Also manage scoring a path and optional character.\r\n\r\n/**\r\n *\r\n * @param {string} string\r\n * @param {Query} preparedQuery\r\n * @param {ScoringOptions} options\r\n * @returns {number}\r\n */\r\nexport function score(string, preparedQuery, options) {\r\n    let {allowErrors} = options;\r\n    if (!allowErrors && !isMatch(string, preparedQuery.core_lw, preparedQuery.core_up)) {\r\n        return 0;\r\n    }\r\n    let string_lw = string.toLowerCase();\r\n    let score = computeScore(string, string_lw, preparedQuery, options);\r\n    score = scorePath(string, string_lw, score, preparedQuery, options);\r\n    return Math.ceil(score);\r\n}\r\n\r\n\r\n// \r\n//  Score adjustment for path\r\n// \r\n\r\nfunction scorePath(subject, subject_lw, fullPathScore, preparedQuery, options) {\r\n\r\n    if (fullPathScore === 0) {\r\n        return 0;\r\n    }\r\n\r\n    let {useExtensionBonus, pathSeparator} = options;\r\n\r\n    //  Skip trailing slashes\r\n    let end = subject.length - 1;\r\n    while (subject[end] === pathSeparator) {\r\n        end--;\r\n    }\r\n\r\n    //  Get position of basePath of subject.\r\n    let basePos = subject.lastIndexOf(pathSeparator, end);\r\n    let fileLength = end - basePos;\r\n\r\n    //  Get a bonus for matching extension\r\n    let extAdjust = 1.0;\r\n\r\n    if (useExtensionBonus) {\r\n        extAdjust += getExtensionScore(subject_lw, preparedQuery.ext, basePos, end, 2);\r\n        fullPathScore *= extAdjust;\r\n    }\r\n\r\n    //  no basePath, nothing else to compute.\r\n    if (basePos === -1) {\r\n        return fullPathScore;\r\n    }\r\n\r\n    //  Get the number of folder in query\r\n    let {depth} = preparedQuery;\r\n\r\n    //  Get that many folder from subject\r\n    while (basePos > -1 && depth-- > 0) {\r\n        basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\r\n    }\r\n\r\n    //  Get basePath score, if BaseName is the whole string, no need to recompute\r\n    //  We still need to apply the folder depth and filename penalty.\r\n    let basePathScore = (basePos === -1) ? fullPathScore :\r\n    extAdjust * computeScore(subject.slice(basePos + 1, end + 1), subject_lw.slice(basePos + 1, end + 1), preparedQuery, options);\r\n\r\n    //  Final score is linear interpolation between base score and full path score.\r\n    //  For low directory depth, interpolation favor base Path then include more of full path as depth increase\r\n    //\r\n    //  A penalty based on the size of the basePath is applied to fullPathScore\r\n    //  That way, more focused basePath match can overcome longer directory path.\r\n\r\n    let alpha = (0.5 * tau_depth) / ( tau_depth + countDir(subject, end + 1, pathSeparator) );\r\n    return (alpha * basePathScore) + ((1 - alpha) * fullPathScore * scoreSize(0, file_coeff * (fileLength)));\r\n}\r\n\r\n\r\n// \r\n//  Count number of folder in a path.\r\n//  (consecutive slashes count as a single directory)\r\n// \r\n\r\nexport function countDir(path, end, pathSeparator) {\r\n    if (end < 1) {\r\n        return 0;\r\n    }\r\n\r\n    let count = 0;\r\n    let i = 0;\r\n\r\n    // skip slash at the start of string\r\n    // so `foo/bar` and `/foo/bar` have the same depth.\r\n    while (i < end && path[i] === pathSeparator){\r\n        i++;\r\n    }\r\n\r\n    // scan for path separator\r\n    while (i < end) {\r\n\r\n        if (path[i] === pathSeparator) {\r\n\r\n            //When path found increase directory depth\r\n            count++;\r\n\r\n            //But treat multiple consecutive pathSeparator as one\r\n            while (i < end && path[i] === pathSeparator) {\r\n                i++;\r\n            }\r\n        }\r\n\r\n        i++;\r\n\r\n    }\r\n\r\n    return count;\r\n}\r\n\r\n// \r\n//  Find fraction of extension that is matched by query.\r\n//  For example mf.h prefers myFile.h to myfile.html\r\n//  This need special handling because it give point for not having characters (the `tml` in above example)\r\n// \r\n\r\nexport function getExtension(str) {\r\n    let pos = str.lastIndexOf(\".\");\r\n    if (pos < 0) {\r\n        return \"\";\r\n    } else {\r\n        return str.substr(pos + 1);\r\n    }\r\n}\r\n\r\n\r\nexport function getExtensionScore(candidate, ext, startPos, endPos, maxDepth) {\r\n    //  startPos is the position of last slash of candidate, -1 if absent.\r\n\r\n    if (ext == null || !ext.length) {\r\n        return 0;\r\n    }\r\n\r\n    //  Check that (a) extension exist, (b) it is after the init of the basename\r\n    let pos = candidate.lastIndexOf(\".\", endPos);\r\n    if (pos <= startPos) {\r\n        return 0;\r\n    } //  (note that startPos >= -1)\r\n\r\n    let n = ext.length;\r\n    let m = endPos - pos;\r\n\r\n    //  n contain the smallest of both extension length, m the largest.\r\n    if (m < n) {\r\n        n = m;\r\n        m = ext.length;\r\n    }\r\n\r\n    // place cursor after dot & count number of matching characters in extension\r\n    pos++;\r\n    let matched = -1;\r\n    while (++matched < n) {\r\n        if (candidate[pos + matched] !== ext[matched]) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    //  if nothing found, try deeper for multiple extensions, with some penalty for depth\r\n    if (matched === 0 && maxDepth > 0) {\r\n        return 0.9 * getExtensionScore(candidate, ext, startPos, pos - 2, maxDepth - 1);\r\n    }\r\n\r\n    //  cannot divide by zero because m is the largest extension length and we return if either is 0\r\n    return matched / m;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/pathScorer.js","/**\r\n *\r\n * @param env\r\n * @returns {{queryOptions: QueryOptions, scoringOptions: ScoringOptions, filterOptions: FilterOptions, matchOptions: MatchOptions, wrapOptions: WrapOptions}}\r\n */\r\n\r\nexport function getDefaults(env) {\r\n\r\n    let defaultPathSeparator = env.defaultPathSeparator;\r\n\r\n    /**\r\n     * @typedef {Object} QueryOptions\r\n     * @property {string} pathSeparator - If candidate are path, indicate path separator used (usually '/' or '\\\\').\r\n     * @property {RegExp} optCharRegEx - Regex that identify character that does not have to match exactly, for example <whitespace>.\r\n     *\r\n     */\r\n\r\n    /**\r\n     * @type {QueryOptions}\r\n     */\r\n    let queryOptions = {\r\n        pathSeparator: defaultPathSeparator,\r\n        optCharRegEx: null,\r\n    };\r\n\r\n    /**\r\n     * @typedef {Object} ScoringOptions\r\n     * @extends QueryOptions\r\n     *\r\n     * @property {boolean} strictUpperCase - With this on, uppercase must be matched by another uppercase.\r\n     *                                       With this off, same case is preferred but not mandatory.\r\n     * @property {boolean} allowErrors - Should we allow candidates that does not have all characters of query ?\r\n     * @property {boolean} usePathScoring - Should we try to interpret candidates as path\r\n     * @property {boolean} useExtensionBonus - Should we try to interpret extension from query\r\n     *                                         and prefer files that match that extension (needs usePathScoring)\r\n     * @property {Query} preparedQuery - If you have a precomputed query object set it here.\r\n     */\r\n\r\n    /**\r\n     * @type {ScoringOptions}\r\n     */\r\n    let scoringOptions = extend(queryOptions, {\r\n        strictUpperCase: false,\r\n        allowErrors: false,\r\n        usePathScoring: true,\r\n        useExtensionBonus: false,\r\n        preparedQuery: null,\r\n    });\r\n\r\n\r\n    /**\r\n     * @typedef {Object} FilterOptions\r\n     * @extends ScoringOptions\r\n     *\r\n     * @property {string|function|null} key - Name of the property that contain string ot be scored\r\n     *                                   or function that input candidate and output string to be scored.\r\n     *\r\n     * @property {number|null} maxResults - Output the top `maxResults` best results at most.\r\n     * @property {bool} outputScore - If true output is an array of {candidate,score} else output is an array of candidates\r\n     *\r\n     */\r\n\r\n    /**\r\n     * @type {FilterOptions}\r\n     */\r\n    let filterOptions = extend(scoringOptions, {\r\n        key: null,\r\n        maxResults: null,\r\n        outputScore: false\r\n    });\r\n\r\n\r\n    /**\r\n     * @typedef {Object} MatchOptions\r\n     * @extends ScoringOptions\r\n     *\r\n     */\r\n\r\n    /**\r\n     * @type {MatchOptions}\r\n     */\r\n    let matchOptions = extend(scoringOptions, {});\r\n\r\n\r\n    /**\r\n     * @typedef {Object} WrapOptions\r\n     * @extends MatchOptions\r\n     *\r\n     * @property {string} tagOpen - string to place before a match default to `<strong class=\"highlight\">`\r\n     * @property {string} tagClose - string to place after a match default to `</strong>`\r\n     * @property {string} tagClass - change the class of the default open tag (tagOpen must be unset)\r\n     *\r\n     */\r\n\r\n    /**\r\n     * @type {WrapOptions}\r\n     */\r\n    let wrapOptions = extend(matchOptions, {\r\n        tagOpen: '<strong class=\"{tagClass}\">',\r\n        tagClose: '</strong>',\r\n        tagClass: 'highlight',\r\n    });\r\n\r\n\r\n    return {\r\n        queryOptions,\r\n        scoringOptions,\r\n        filterOptions,\r\n        matchOptions,\r\n        wrapOptions\r\n    };\r\n\r\n}\r\n\r\nexport function extend(reference, target) {\r\n\r\n    let hasOwnProperty = Object.prototype.hasOwnProperty;\r\n    for (let key in reference) {\r\n        if (hasOwnProperty.call(reference, key) && !hasOwnProperty.call(target, key)) {\r\n            target[key] = reference[key];\r\n        }\r\n    }\r\n\r\n    return target;\r\n\r\n}\r\n\r\nexport default {\r\n    getDefaults,\r\n    extend\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/definitions/defaultOptions.js","\r\nexport class FilterState {\r\n\r\n    constructor() {\r\n\r\n        // Filter result mechanic\r\n        this.isPending = true;\r\n        this.cancelRequest = false;\r\n        this.discardResults = false;\r\n        this.count = 0;\r\n\r\n        // Specific to scoring\r\n        this.scoredCandidates = null;\r\n        this.scoreProvider = null;\r\n        this.accessor = null;\r\n\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @typedef {Object} FilterResult\r\n *\r\n * @method  cancel - stop scoring and return no results.\r\n * @method  isCanceled - has the filter been canceled.\r\n * @method  isPending - filter is in progress or haven't started.\r\n * @method  getProgress - get the count of processed elements.\r\n *\r\n */\r\n\r\n\r\nexport class FilterResult {\r\n\r\n    /**\r\n     * @param {FilterState} state\r\n     */\r\n\r\n    constructor( state ) {\r\n\r\n        // Closure over the internal state to avoid manual changes.\r\n\r\n        this.cancel = function cancel(keepResults = false){\r\n            state.isPending = false;\r\n            state.cancelRequest = true;\r\n            state.discardResults = !keepResults;\r\n        };\r\n\r\n        this.isCanceled = function isCanceled(){\r\n            return state.cancelRequest;\r\n        };\r\n\r\n        this.isPending = function isPending(){\r\n            return state.isPending;\r\n        };\r\n\r\n        this.getProgress = function getProgress(){\r\n            return state.count;\r\n        };\r\n\r\n    }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/definitions/filterState.js","import {filterSync as processFilterSync, filterAsync as processFilterAsync} from \"./lib/filter\";\r\nimport {score as processScore} from \"./lib/scorer\";\r\nimport {score as processPathScore} from \"./lib/pathScorer\";\r\nimport {match as processMatch, wrap as processWrap} from \"./lib/matcher\";\r\nimport {Query} from \"./lib/query\";\r\nimport {getDefaults, extend} from \"./definitions/defaultOptions\"\r\nimport {env} from \"./lib/env\"\r\n\r\nlet defaultOptions = getDefaults(env);\r\n\r\nconst fuzzaldrin = {\r\n    filter,\r\n    score,\r\n    match,\r\n    wrap,\r\n    prepareQuery,\r\n    defaultOptions\r\n};\r\n\r\nexport default fuzzaldrin\r\n\r\n// Export main object to global window.\r\nif(env.isBrowser){\r\n    window.fuzzaldrin = fuzzaldrin;\r\n}\r\n\r\nlet preparedQueryCache = null;\r\n\r\n\r\n/**\r\n * Filter:\r\n *  Given a list of candidate, output a list of candidate that match query.\r\n *  Output list is the same format (string or object) than input list.\r\n *\r\n *  If given a list of object, specify options.key as the property `candidate[key]`\r\n *  that contain the string representation of the candidate\r\n *\r\n *  Output is sorted by match score.\r\n *\r\n * @param {Array.<(string|object)>|Iterable} candidates - array of string or objects\r\n * @param {string} query - string to search for in each candidate\r\n * @param {FilterOptions=} options - (optional) see option hash doc\r\n * @returns {Array.<(string|object)>} - filtered & sorted subset of input candidates\r\n */\r\n\r\nexport function filter(candidates, query, options) {\r\n\r\n    if (!checkString(query)) return [];\r\n    if (!checkCollection(candidates)) return [];\r\n\r\n    options = parseOptions(options, defaultOptions.filterOptions);\r\n    let preparedQuery = getPreparedQuery(query, options);\r\n\r\n    return processFilterSync(candidates, preparedQuery, options);\r\n\r\n}\r\n\r\n/**\r\n *\r\n * @param candidates\r\n * @param query\r\n * @param options\r\n * @param {filterCallback} callback\r\n * @returns {FilterResult}\r\n */\r\n\r\nexport function filterAsync(candidates, query, callback, options) {\r\n\r\n    if (!checkString(query)) return [];\r\n    if (!checkCollection(candidates)) return [];\r\n\r\n    options = parseOptions(options, defaultOptions.filterOptions);\r\n    let preparedQuery = getPreparedQuery(query, options);\r\n\r\n    return processFilterAsync(candidates, preparedQuery, callback, options);\r\n\r\n}\r\n\r\n/**\r\n * Score:\r\n *   Give the numerical score on how a given string match query.\r\n *\r\n *   This is provided so you can build your own filter method.\r\n *   For example you may have a special way to iterate candidate,\r\n *   access candidate string representation, or you may need to\r\n *   modify the score to account external knowledge (eg last modified date)\r\n *\r\n * @param {string} string - string representation of a candidate\r\n * @param {string} query - string to search for in candidate\r\n * @param {ScoringOptions=} options - (optional) see option hash doc\r\n * @returns {number} score 0 .. max, where max is score(string, string)\r\n */\r\n\r\nexport function score(string, query, options) {\r\n\r\n    if (!checkString(string)) return 0;\r\n    if (!checkString(query)) return 0;\r\n\r\n    options = parseOptions(options, defaultOptions.scoringOptions);\r\n    let preparedQuery = getPreparedQuery(query, options);\r\n\r\n    if (options.usePathScoring) {\r\n        return processPathScore(string, preparedQuery, options);\r\n    } else {\r\n        return processScore(string, preparedQuery, options);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Match:\r\n *    Communicate which characters of candidate where selected by the algorithm to represent the query.\r\n *    The match function output an array of character position.\r\n *    If you need to display those character as an html string see wrap function.\r\n *\r\n * @param {string} string - string representation of a candidate\r\n * @param {string} query - string to search for in candidate\r\n * @param {MatchOptions=} options (optional)\r\n * @returns {Array.<number>}\r\n */\r\n\r\nexport function match(string, query, options) {\r\n\r\n    if (!checkString(string)) return [];\r\n    if (!checkString(query)) return [];\r\n\r\n    //If both are the same, return an array of consecutive numbers\r\n    if (string === query) {\r\n        let length = string.length;\r\n        let range = new Array(length);\r\n        for (let idx = 0; idx < length; idx++) {\r\n            range[idx] = idx;\r\n        }\r\n        return range;\r\n    }\r\n\r\n    options = parseOptions(options, defaultOptions.matchOptions);\r\n    let preparedQuery = getPreparedQuery(query, options);\r\n\r\n    return processMatch(string, preparedQuery, options);\r\n}\r\n\r\n\r\n/**\r\n * Wrap:\r\n *    Communicate which characters of candidate where selected by the algorithm to represent the query.\r\n *    This function output the given string with chosen character wrapped in a delimiter string (eg html tag).\r\n *\r\n *    To control the wrap use the option hash.\r\n *    Here are some default value:\r\n *      options.tagOpen = `<strong class=\"highlight\">`\r\n *      options.tagClose = `</strong>`\r\n *\r\n *    Alternatively, if you chose to keep the default tagOpen,\r\n *    you can specify option.tagClass and change the `highlight`\r\n *    class to one of your choosing.\r\n *\r\n *    Wrap method will try to group consecutive matches under the same tag.\r\n *\r\n * @param {string} string - string representation of a candidate\r\n * @param {string} query - string to search for in candidate\r\n * @param {WrapOptions=} options\r\n * @returns {string} - input string with match wrapped in open and close tag.\r\n */\r\n\r\nexport function wrap(string, query, options) {\r\n\r\n    if (!checkString(string)) return \"\";\r\n    if (!checkString(query)) return string;\r\n\r\n    options = parseOptions(options, defaultOptions.wrapOptions);\r\n    let preparedQuery = getPreparedQuery(query, options);\r\n\r\n    return processWrap(string, query, options);\r\n\r\n}\r\n\r\n/**\r\n * PrepareQuery:\r\n *   The usual scenario is to compare a single query with multiple candidate.\r\n *   To speed that process up, we pre-compute some information about the query.\r\n *\r\n *   Pre-computed query is natural to use in bulk method like filter, but harder\r\n *   in one-by-one method like score or match. To keep those method fast you can give\r\n *   a pre computed query in option hash as `options.preparedQuery`\r\n *\r\n *   Note that we use an internal cache `preparedQueryCache` that cover most of the simple cases\r\n *   So this method may not be needed in thos cases.\r\n *\r\n * @param {string} query\r\n * @param {QueryOptions} options\r\n * @returns {Query}\r\n */\r\n\r\nexport function prepareQuery(query, options) {\r\n    options = parseOptions(options);\r\n    return getPreparedQuery(query, options);\r\n}\r\n\r\nfunction checkString(str){\r\n    //Not null, must have length property > 0\r\n    return str != null && str.length != null && str.length > 0;\r\n}\r\n\r\nfunction checkCollection(obj){\r\n    // Not null\r\n    // If object has length or size property, must be != 0\r\n    // Example of thing with size: (es6 sets, ImmutableJs collections)\r\n    return obj != null && obj.length !== 0 && obj.size !== 0\r\n}\r\n\r\n\r\n\r\n\r\n//\r\n// Setup default values\r\n//\r\n\r\n\r\n\r\n\r\nfunction parseOptions(options, defaultOptions) {\r\n\r\n    // If no options given, copy default\r\n    // Else merge options with defaults.\r\n    if(options == null) options = {};\r\n    return extend(defaultOptions, options);\r\n\r\n}\r\n\r\nfunction getPreparedQuery(query, options){\r\n\r\n    // If prepared query in option hash is valid, use it\r\n    if(options.preparedQuery != null && options.preparedQuery.query === query)\r\n        return options.preparedQuery;\r\n\r\n    // Recompute cache if empty or invalid\r\n    if (preparedQueryCache == null || preparedQueryCache.query !== query) {\r\n        preparedQueryCache = new Query(query, options)\r\n    }\r\n\r\n    // Serve from cache\r\n    return preparedQueryCache;\r\n\r\n}\r\n\r\n\r\n//\r\n// Async\r\n//\r\n\r\n/**\r\n * @callback filterCallback\r\n * @param {Array} results\r\n * @param {FilterResult} state\r\n */\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/fuzzaldrin-plus.js","//\r\n// Detect node.js or browser to set default path separator\r\n//\r\n\r\nlet isNode = (typeof process === 'object' && Object.prototype.toString.call(process) === '[object process]');\r\nlet isBrowser = !isNode && (typeof window === 'object' && Object.prototype.toString.call(window) === \"[object Window]\");\r\n\r\n// On node js we assume the list of candidates match local OS path format.\r\n// While on browser assume that we are dealing with url\r\n// Use 'options.pathSeparator' if you need a behavior different from those assumptions.\r\nlet defaultPathSeparator = ( isNode && process.platform === \"win32\") ? \"\\\\\" : \"/\";\r\n\r\nexport let env = {\r\n    isNode,\r\n    isBrowser,\r\n    defaultPathSeparator\r\n};\r\n\r\nexport default{\r\n    env\r\n}\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/env.js","import scorer from \"./scorer\";\r\nimport pathScorer from \"./pathScorer\";\r\nimport utils from \"./utils\";\r\nimport {FilterResult, FilterState} from '../definitions/filterState'\r\n\r\n\r\nexport default {\r\n    filterSync,\r\n    filterAsync\r\n};\r\n\r\n/**\r\n *\r\n * @param {Array|Iterable} candidates\r\n * @param {Query} preparedQuery\r\n * @param {FilterOptions} options\r\n * @returns {Array}\r\n */\r\n\r\nexport function filterSync(candidates, preparedQuery,  options) {\r\n    let state = new FilterState();\r\n    return executeFilter(candidates, preparedQuery, state, options)\r\n}\r\n\r\n/**\r\n *\r\n * @param {Array|Iterable} candidates\r\n * @param {Query} preparedQuery\r\n * @param {FilterOptions} options\r\n * @param {filterCallback} callback\r\n * @returns {FilterResult}\r\n */\r\n\r\n\r\nexport function filterAsync(candidates, preparedQuery,  callback, options) {\r\n\r\n    let internalState = new FilterState();\r\n    let filterResult = new FilterResult(internalState);\r\n\r\n    let scheduled = () => {\r\n        callback( executeFilter(candidates, preparedQuery, internalState, options), filterResult );\r\n    };\r\n\r\n    if(typeof setImmediate === \"function\"){\r\n        setImmediate(scheduled)\r\n    }else{\r\n        setTimeout(scheduled,0)\r\n    }\r\n\r\n    return filterResult;\r\n\r\n}\r\n\r\n/**\r\n *\r\n * @param {Array|Iterable} candidates\r\n * @param {Query} preparedQuery\r\n * @param {FilterState} state\r\n * @param {FilterOptions} options\r\n * @returns {Array}\r\n */\r\n\r\nfunction executeFilter(candidates, preparedQuery, state, options) {\r\n\r\n    if(state.cancelRequest) return [];\r\n\r\n    // See option parsing on main module for default\r\n    const {key, maxResults, outputScore, usePathScoring} = options;\r\n\r\n    // If list of object, we need to get the string to be scored, as defined by options.key\r\n    // If the key is a method, that method should take an object and return the string.\r\n    // Else we assume it is the name of a property on candidate object.\r\n    let accessor = null;\r\n    if(key != null){\r\n        accessor =  utils.isFunction(options.key) ? options.key : (x) => x[key]\r\n    }\r\n\r\n    // Init state\r\n    state.isPending = true;\r\n    state.accessor = accessor;\r\n    state.scoreProvider = usePathScoring ? pathScorer : scorer;\r\n    state.scoredCandidates = [];\r\n\r\n    // Iterate candidate list and collect scored positive matches.\r\n    processCollection(candidates, preparedQuery, state, options);\r\n\r\n    // Collect positives matches\r\n    let scoredCandidates = state.scoredCandidates;\r\n\r\n    // Cleanup\r\n    state.scoredCandidates = null;\r\n    state.isPending = false;\r\n\r\n    // Quick exit\r\n    if(state.discardResults || scoredCandidates==null || !scoredCandidates.length ) return [];\r\n\r\n    // Sort scores in descending order\r\n    scoredCandidates.sort(sortCandidates);\r\n\r\n    // Trim to maxResults if specified\r\n    if (maxResults != null) {\r\n        scoredCandidates = scoredCandidates.slice(0, maxResults);\r\n    }\r\n\r\n    // Return either a sorted list of candidate or list of candidate-score pairs.\r\n    if(outputScore === true){\r\n        return scoredCandidates;\r\n    }else{\r\n        // Extract original candidate and return\r\n        return scoredCandidates.map(pluckCandidates);\r\n    }\r\n\r\n}\r\n\r\nfunction processCollection(collection, preparedQuery, state, options){\r\n\r\n    //\r\n    // Collection is an array\r\n    //\r\n\r\n    if( utils.isArray(collection) ){\r\n        for(let i = 0; i<= collection.length; i++){\r\n            if( !processItem( collection[i], preparedQuery, state, options) ) break;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //\r\n    // Collection is an Iterable or Iterator (es6 protocol)\r\n    //\r\n\r\n    let iterator = utils.getIterator(collection);\r\n    if(iterator != null){\r\n        let item = iterator.next();\r\n        if(utils.isIteratorItem(item)){\r\n            while(!item.done){\r\n                if( !processItem( item.value, preparedQuery, state, options) ) break;\r\n                item = iterator.next()\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n\r\n    //\r\n    // Collection implements 'forEach'\r\n    //\r\n\r\n    // Some implementations  of foreach allow to exit using return false. (Eg Immutablejs)\r\n    //      processItem follow that convention .\r\n    //\r\n    // Others cannot be interrupted ( Eg default Array.forEach )\r\n    //      so we continue iteration but short circuit most of the work.\r\n\r\n    let cont = true;\r\n    if( utils.isFunction(collection.forEach) ) {\r\n        collection.forEach((item) => cont = cont && processItem(item, preparedQuery, state, options));\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n *\r\n * @param {string|object} candidate\r\n * @param {Query} preparedQuery\r\n * @param {FilterState} context\r\n * @param {FilterOptions} options\r\n * @returns {boolean}\r\n */\r\n\r\nfunction processItem(candidate, preparedQuery, context, options){\r\n\r\n    if(context.cancelRequest) return false;\r\n    context.count++;\r\n\r\n    let {accessor, scoredCandidates, scoreProvider } = context;\r\n\r\n    // Get the string representation of candidate\r\n    let string = accessor != null ? accessor(candidate) : candidate;\r\n    if (string == null || !string.length) return true;\r\n\r\n    // Get score, If score greater than 0 add to valid results\r\n    let score = scoreProvider.score(string, preparedQuery, options);\r\n    if (score > 0) scoredCandidates.push({candidate, score});\r\n\r\n    return true;\r\n\r\n}\r\n\r\n\r\nfunction pluckCandidates(a) {\r\n    return a.candidate;\r\n}\r\n\r\nfunction sortCandidates(a, b) {\r\n    return b.score - a.score;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/filter.js","// A match list is an array of indexes to characters that match.\r\n// This file should closely follow `scorer` except that it returns an array\r\n// of indexes instead of a score.\r\nimport {isMatch, isWordStart, scoreConsecutives, scoreCharacter, scoreAcronyms} from \"./scorer\";\r\n\r\n\r\nexport default{\r\n    match,\r\n    wrap,\r\n}\r\n\r\n\r\n// Return position of character which matches\r\n\r\n/**\r\n *\r\n * @param {string} string\r\n * @param {Query} preparedQuery\r\n * @param {MatchOptions} options\r\n * @returns {Array.<number>}\r\n */\r\nexport function match(string, preparedQuery, options) {\r\n\r\n    let {allowErrors, pathSeparator} = options;\r\n\r\n    if (!allowErrors && !isMatch(string, preparedQuery.core_lw, preparedQuery.core_up)) {\r\n        return [];\r\n    }\r\n    let string_lw = string.toLowerCase();\r\n\r\n    // Full path results\r\n    let matches = computeMatch(string, string_lw, preparedQuery);\r\n\r\n    //if there is no matches on the full path, there should not be any on the base path either.\r\n    if (matches.length === 0) {\r\n        return matches;\r\n    }\r\n\r\n    // Is there a base path ?\r\n    if (string.indexOf(pathSeparator) > -1) {\r\n\r\n        // Base path results\r\n        let baseMatches = basenameMatch(string, string_lw, preparedQuery, pathSeparator);\r\n\r\n        // Combine the results, removing duplicate indexes\r\n        matches = mergeMatches(matches, baseMatches);\r\n    }\r\n\r\n    return matches;\r\n}\r\n\r\n\r\n//\r\n// Wrap\r\n//\r\n// Helper around match if you want a string with result wrapped by some delimiter text\r\n\r\n/**\r\n *\r\n * @param {string} string\r\n * @param {Query} preparedQuery\r\n * @param {WrapOptions} options\r\n * @returns {*}\r\n */\r\nexport function wrap(string, preparedQuery, options) {\r\n\r\n    let {tagClass, tagOpen, tagClose} = options;\r\n\r\n    if(tagOpen && tagOpen.length){\r\n        tagOpen = tagOpen.replace(\"{tagClass}\", tagClass);\r\n    }\r\n\r\n    if (string === preparedQuery.query) {\r\n        return tagOpen + string + tagClose;\r\n    }\r\n\r\n    //Run get position where a match is found\r\n    let matchPositions = match(string, preparedQuery, options);\r\n    let nbMatches = matchPositions.length;\r\n\r\n    //If no match return as is\r\n    if (nbMatches === 0) {\r\n        return string;\r\n    }\r\n\r\n    //Loop over match positions\r\n    let output = '';\r\n    let matchIndex = -1;\r\n    let strPos = 0;\r\n    while (++matchIndex < nbMatches) {\r\n        let matchPos = matchPositions[matchIndex];\r\n\r\n        // Get text before the current match position\r\n        if (matchPos > strPos) {\r\n            output += string.substring(strPos, matchPos);\r\n            strPos = matchPos;\r\n        }\r\n\r\n        // Get consecutive matches to wrap under a single tag\r\n        while (++matchIndex < nbMatches) {\r\n            if (matchPositions[matchIndex] === matchPos + 1) {\r\n                matchPos++;\r\n            } else {\r\n                matchIndex--;\r\n                break;\r\n            }\r\n        }\r\n\r\n        //Get text inside the match, including current character\r\n        matchPos++;\r\n        if (matchPos > strPos) {\r\n            output += tagOpen;\r\n            output += string.substring(strPos, matchPos);\r\n            output += tagClose;\r\n            strPos = matchPos;\r\n        }\r\n    }\r\n\r\n    //Get string after last match\r\n    if (strPos < string.length - 1) {\r\n        output += string.substring(strPos);\r\n    }\r\n\r\n    //return wrapped text\r\n    return output;\r\n}\r\n\r\n\r\nfunction basenameMatch(subject, subject_lw, preparedQuery, pathSeparator) {\r\n\r\n    // Skip trailing slashes\r\n    let end = subject.length - 1;\r\n    while (subject[end] === pathSeparator) {\r\n        end--;\r\n    }\r\n\r\n    // Get position of basePath of subject.\r\n    let basePos = subject.lastIndexOf(pathSeparator, end);\r\n\r\n    //If no PathSeparator, no base path exist.\r\n    if (basePos === -1) {\r\n        return [];\r\n    }\r\n\r\n    // Get the number of folder in query\r\n    let {depth} = preparedQuery;\r\n\r\n    // Get that many folder from subject\r\n    while (depth-- > 0) {\r\n        basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\r\n        if (basePos === -1) {\r\n            return [];\r\n        }\r\n    } //consumed whole subject ?\r\n\r\n    // Get basePath match\r\n    basePos++;\r\n    end++;\r\n    return computeMatch(subject.slice(basePos, end), subject_lw.slice(basePos, end), preparedQuery, basePos);\r\n}\r\n\r\n\r\n//\r\n// Combine two matches result and remove duplicate\r\n// (Assume sequences are sorted, matches are sorted by construction.)\r\n//\r\n\r\nfunction mergeMatches(a, b) {\r\n    let m = a.length;\r\n    let n = b.length;\r\n\r\n    if (n === 0) {\r\n        return a.slice();\r\n    }\r\n    if (m === 0) {\r\n        return b.slice();\r\n    }\r\n\r\n    let i = -1;\r\n    let j = 0;\r\n    let bj = b[j];\r\n    let out = [];\r\n\r\n    while (++i < m) {\r\n        let ai = a[i];\r\n\r\n        while (bj <= ai && ++j < n) {\r\n            if (bj < ai) {\r\n                out.push(bj);\r\n            }\r\n            bj = b[j];\r\n        }\r\n\r\n        out.push(ai);\r\n    }\r\n\r\n    while (j < n) {\r\n        out.push(b[j++]);\r\n    }\r\n\r\n    return out;\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n\r\n//\r\n// Align sequence (used for fuzzaldrin.match)\r\n// Return position of subject characters that match query.\r\n//\r\n// Follow closely scorer.computeScore.\r\n// Except at each step we record what triggered the best score.\r\n// Then we trace back to output matched characters.\r\n//\r\n// Differences are:\r\n// - we record the best move at each position in a matrix, and finish by a traceback.\r\n// - we reset consecutive sequence if we do not take the match.\r\n// - no hit miss limit\r\n\r\n\r\nfunction computeMatch(subject, subject_lw, preparedQuery, offset = 0) {\r\n    let {query} = preparedQuery;\r\n    let {query_lw} = preparedQuery;\r\n\r\n    let m = subject.length;\r\n    let n = query.length;\r\n\r\n    //this is like the consecutive bonus, but for camelCase / snake_case initials\r\n    let acro_score = scoreAcronyms(subject, subject_lw, query, query_lw).score;\r\n\r\n    //Init\r\n    let score_row = new Array(n);\r\n    let csc_row = new Array(n);\r\n\r\n    // Directions constants\r\n    let STOP = 0;\r\n    let UP = 1;\r\n    let LEFT = 2;\r\n    let DIAGONAL = 3;\r\n\r\n    //Traceback matrix\r\n    let trace = new Array(m * n);\r\n    let pos = -1;\r\n\r\n    //Fill with 0\r\n    let j = -1; //0..n-1\r\n    while (++j < n) {\r\n        score_row[j] = 0;\r\n        csc_row[j] = 0;\r\n    }\r\n\r\n    let move;\r\n    let score_diag;\r\n    let score;\r\n    let score_up;\r\n    let csc_diag;\r\n\r\n    let i = -1; //0..m-1\r\n    while (++i < m) { //foreach char si of subject\r\n\r\n        score = 0;\r\n        score_up = 0;\r\n        csc_diag = 0;\r\n\r\n        let si_lw = subject_lw[i];\r\n\r\n        j = -1; //0..n-1\r\n        while (++j < n) { //foreach char qj of query\r\n\r\n            //reset score\r\n            let csc_score = 0;\r\n            let align = 0;\r\n            score_diag = score_up;\r\n\r\n            //Compute a tentative match\r\n            if (query_lw[j] === si_lw) {\r\n\r\n                let start = isWordStart(i, subject, subject_lw);\r\n\r\n                // Forward search for a sequence of consecutive char\r\n                csc_score = csc_diag > 0 ? csc_diag :\r\n                    scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);\r\n\r\n                // Determine bonus for matching A[i] with B[j]\r\n                align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);\r\n            }\r\n\r\n            //Prepare next sequence & match score.\r\n            score_up = score_row[j]; // Current score_up is next run score diag\r\n            csc_diag = csc_row[j];\r\n\r\n            //In case of equality, moving UP get us closer to the init of the candidate string.\r\n            if (score > score_up) {\r\n                move = LEFT;\r\n            } else {\r\n                score = score_up;\r\n                move = UP;\r\n            }\r\n\r\n            // Only take alignment if it's the absolute best option.\r\n            if (align > score) {\r\n                score = align;\r\n                move = DIAGONAL;\r\n            } else {\r\n                //If we do not take this character, break consecutive sequence.\r\n                // (when consecutive is 0, it'll be recomputed)\r\n                csc_score = 0;\r\n            }\r\n\r\n            score_row[j] = score;\r\n            csc_row[j] = csc_score;\r\n            trace[++pos] = (score > 0) ? move : STOP;\r\n        }\r\n    }\r\n\r\n    // -------------------\r\n    // Go back in the trace matrix\r\n    // and collect matches (diagonals)\r\n\r\n    i = m - 1;\r\n    j = n - 1;\r\n    pos = (i * n) + j;\r\n    let backtrack = true;\r\n    let matches = [];\r\n\r\n    while (backtrack && i >= 0 && j >= 0) {\r\n        switch (trace[pos]) {\r\n            case UP:\r\n                i--;\r\n                pos -= n;\r\n                break;\r\n            case LEFT:\r\n                j--;\r\n                pos--;\r\n                break;\r\n            case DIAGONAL:\r\n                matches.push(i + offset);\r\n                j--;\r\n                i--;\r\n                pos -= n + 1;\r\n                break;\r\n            default:\r\n                backtrack = false;\r\n        }\r\n    }\r\n\r\n    matches.reverse();\r\n    return matches;\r\n}\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/matcher.js","//\r\n// Query object\r\n//\r\n// Allow to reuse some quantities computed from query.\r\n// Optional char can optionally be specified in the form of a regular expression.\r\n//\r\nimport {countDir, getExtension} from \"./pathScorer\";\r\n\r\nexport class Query {\r\n\r\n    /**\r\n     *\r\n     * @param {string} query\r\n     * @param {QueryOptions} options\r\n     */\r\n    constructor(query, options) {\r\n\r\n        if (query == null || !query.length) {\r\n            return;\r\n        }\r\n\r\n        this.query = query;\r\n        this.query_lw = query.toLowerCase();\r\n        this.core = coreChars(query, options.optCharRegEx);\r\n        this.core_lw = this.core.toLowerCase();\r\n        this.core_up = truncatedUpperCase(this.core);\r\n        this.depth = countDir(query, query.length, options.pathSeparator);\r\n        this.ext = getExtension(this.query_lw);\r\n        this.charCodes = getCharCodes(this.query_lw);\r\n    }\r\n}\r\n\r\n\r\n//\r\n// Optional chars\r\n// Those char improve the score if present, but will not block the match (score=0) if absent.\r\n\r\nconst opt_char_re = /[ _\\-:\\/\\\\]/g;\r\n\r\n/**\r\n *\r\n * @param {string} query\r\n * @param {RegExp} optCharRegEx\r\n * @returns {string}\r\n */\r\nfunction coreChars(query, optCharRegEx) {\r\n\r\n    if (optCharRegEx == null) {\r\n        optCharRegEx = opt_char_re\r\n    }\r\n\r\n    return query.replace(optCharRegEx, '');\r\n}\r\n\r\n//\r\n// Truncated Upper Case:\r\n// --------------------\r\n//\r\n// A fundamental mechanic is that we are able to keep uppercase and lowercase variant of the strings in sync.\r\n// For that we assume uppercase and lowercase version of the string have the same length.\r\n// Of course unicode being unicode there's exceptions.\r\n// See ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt for the list\r\n//\r\n// \"Strae\".toUpperCase() -> \"STRASSE\"\r\n// truncatedUpperCase(\"Strae\") -> \"STRASE\"\r\n// iterating over every character, getting uppercase variant and getting first char of that.\r\n//\r\n\r\nfunction truncatedUpperCase(str) {\r\n    let upper = \"\";\r\n    for (let char of str) {\r\n        upper += char.toUpperCase()[0];\r\n    }\r\n    return upper;\r\n}\r\n\r\n//\r\n// Get character codes:\r\n// --------------------\r\n//\r\n// Get character codes map for a given string\r\n//\r\n\r\nfunction getCharCodes(str) {\r\n    let len = str.length;\r\n    let i = -1;\r\n\r\n    let charCodes = [];\r\n    // create map\r\n    while (++i < len) {\r\n        charCodes[str.charCodeAt(i)] = true;\r\n    }\r\n\r\n    return charCodes;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/query.js","export default {\r\n    isFunction,\r\n    isArray,\r\n    getIterator,\r\n    isIteratorItem\r\n};\r\n\r\nexport function isFunction(fn){\r\n    return typeof fn === \"function\"\r\n}\r\n\r\nexport function isArray(tentativeArray){\r\n\r\n    if( isFunction(Array.isArray) ){\r\n        return Array.isArray(tentativeArray);\r\n    }\r\n\r\n    return Object.prototype.toString.call(tentativeArray) === \"[object Array]\";\r\n\r\n}\r\n\r\n//\r\n// Es6 compatible iterator.\r\n// Follow convention of ImmutableJS\r\n//\r\n\r\nconst REAL_ITERATOR_SYMBOL = (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") ? Symbol.iterator : null;\r\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\r\n\r\nexport function getIterator(object){\r\n\r\n    if(object == null) return null;\r\n\r\n    // Get iterator from Iterable\r\n    let iterator = null;\r\n    if(REAL_ITERATOR_SYMBOL != null && isFunction(object[REAL_ITERATOR_SYMBOL]) ) {\r\n        // real es6 Iterable\r\n        iterator =  object[REAL_ITERATOR_SYMBOL]();\r\n    }\r\n    else if( isFunction(object[REAL_ITERATOR_SYMBOL]) ){\r\n        // es < 6 fallback.\r\n        iterator = object[FAUX_ITERATOR_SYMBOL]();\r\n    }\r\n\r\n    // Ensure that that iterator implements 'next' function\r\n    if(iterator != null && isFunction(iterator.next))\r\n        return iterator;\r\n\r\n    // Test if object itself is iterator-like\r\n    if(isFunction(object.next)){\r\n        return object;\r\n    }\r\n\r\n    return null;\r\n\r\n}\r\n\r\nexport function isIteratorItem(item){\r\n    return  item != null && 'done' in item && 'value' in item\r\n}\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/utils.js"],"sourceRoot":""}